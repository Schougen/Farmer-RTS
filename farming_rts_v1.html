<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Farming RTS â€“ Seasons, Shifts, Snowplow, Stone Picking (Stability Fix + Sunlight & Icons)</title>
<style>
  :root { --bg:#111; --panel:#1b1b1b; --panel2:#222; --line:#333; --accent:#2f7dd8; }
  * { box-sizing:border-box; }
  body { margin:0; background:var(--bg); color:#eee; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif; display:grid; grid-template-columns: 300px 1fr; grid-template-rows:auto auto 1fr; gap:8px; min-height:100vh; height:100vh; }
  header { grid-column:1 / -1; padding:10px 12px; }
  h1 { margin:0; font-size:1.15rem; letter-spacing:.04em; text-transform:uppercase; }
  #hud { grid-column:2 / -1; display:flex; gap:10px; align-items:center; flex-wrap:wrap; padding:0 12px 6px; }
  #stats { padding:6px 10px; border-radius:999px; background:#222; border:1px solid #444; font-size:.9rem; }
  #controls, #modes, #shop { display:flex; gap:8px; flex-wrap:wrap; }
  button { background:var(--accent); border:none; color:#fff; border-radius:999px; padding:6px 12px; font-size:.85rem; cursor:pointer; }
  button.secondary { background:#444; }
  button.ghost { background:transparent; border:1px solid #555; }
  button.tiny { padding:4px 8px; font-size:.78rem; }
  button.active { outline:2px solid #ffd700; }
  button:disabled { background:#555; cursor:default; }
  aside#sidebar { grid-row:2 / -1; grid-column:1; background:var(--panel); border-right:1px solid #3a3a3a; padding:10px; overflow:hidden; display:flex; flex-direction:column; gap:10px; }
  #tileInfo, #unitList, #debug { background:var(--panel2); border:1px solid #3a3a3a; border-radius:10px; padding:10px; margin-bottom:0; }
  #tileInfo h2, #unitList h2, #debug h2 { margin:4px 0 8px; font-size:1rem; }
  .kv { display:grid; grid-template-columns: auto 1fr; gap:4px 8px; font-size:.92rem; }
  .kv span:nth-child(odd){ color:#bbb; }
  .unitCard { background:#1f1f1f; border:1px solid #3a3a3a; border-radius:10px; padding:8px; margin-bottom:8px; }
  .unitHeader { display:flex; justify-content:space-between; align-items:center; }
  .tag { font-size:.75rem; padding:2px 6px; border-radius:8px; background:#444; }
  .unitCard.selected { outline:2px solid #ffd700; }
#unitList {
  flex:1;
  overflow:hidden;
  margin-bottom:0;
  display:flex;
  flex-direction:column;
  min-height:0;
}

#unitList h2 {
  position:sticky;
  top:0;
  background:linear-gradient(180deg, rgba(27,27,27,0.95), rgba(27,27,27,0.85));
  padding-top:0;
  padding-bottom:6px;
  z-index:1;
}

#unitCards {
  overflow:auto;
  padding-right:6px;
  margin-top:4px;
}

.queueList {
  margin:6px 0 0;
  padding-left:0;
  font-size:.85rem;
  color:#ddd;
  max-height:160px;
  overflow:auto;
  padding-right:6px;
  list-style-position:inside;
  font-variant-numeric:tabular-nums;
}
  #boardWrap { grid-column:2; grid-row:3; display:flex; justify-content:center; align-items:center; padding:8px 12px 16px; }
  #gameContainer { background:#000; padding:10px; border-radius:16px; box-shadow:0 0 20px rgba(0,0,0,.6); display:flex; align-items:center; justify-content:center; }
  canvas { border-radius:8px; display:block; background:#223322; width:100%; height:100%; }
  details { grid-column:2; color:#ccc; margin:0 12px 8px; }
  summary { cursor:pointer; font-weight:600; }
  .test-pass { color:#7CFC00; }
  .test-fail { color:#ff6b6b; }
</style>
</head>
<body>
  <header><h1>Farming RTS</h1></header>

  <div id="hud">
    <div id="stats">ðŸ’° <span id="money">0</span> | ðŸ“… Day <span id="day">1</span> | ðŸ•’ <span id="time">08:00</span> | ðŸŒ¦ <span id="season">Spring, Day 1</span> | ðŸ‘· Shift <span id="shift">On</span></div>
    <div id="modes" title="Choose command mode">
      <button class="secondary active" data-mode="auto">Auto</button>
      <button class="secondary" data-mode="move">Move</button>
      <button class="secondary" data-mode="field">Field</button>
      <button class="secondary" data-mode="plow">Plow</button>
      <button class="secondary" data-mode="seed">Seed</button>
      <button class="secondary" data-mode="spray">Spray</button>
      <button class="secondary" data-mode="harvest">Harvest</button>
      <button class="secondary" data-mode="stone">Stone</button>
      <button class="secondary" data-mode="snow">Snow</button>
    </div>
    <div id="controls">
      <button id="pauseBtn">Pause</button>
      <button id="speed1Btn">1Ã—</button>
      <button id="speed3Btn">3Ã—</button>
      <button id="resetBtn" class="ghost">Reset Farm</button>
      <button id="sleepBtn" class="ghost" title="Skip to the next morning">Sleep to 06:00</button>
      <label style="margin-left:8px;font-size:.85rem;display:flex;gap:6px;align-items:center;">
        Preset:
        <select id="preset">
          <option value="real">Realistic</option>
          <option value="assist">Assisted (QoL)</option>
        </select>
      </label>
      <button id="planBtn" class="ghost" title="Auto-queue a full cycle for available machines">Plan Cycle</button>
      <label id="planScopeWrap" style="margin-left:4px;font-size:.85rem;display:flex;gap:6px;align-items:center;">
        Jobs:
        <select id="planScope">
          <option value="all">All jobs</option>
          <option value="plow">Plow only</option>
          <option value="stone">Stone picking only</option>
          <option value="seed">Seed only</option>
          <option value="spray">Spray only</option>
          <option value="harvest">Harvest only</option>
          <option value="snow">Snow clearing only</option>
        </select>
      </label>
    </div>
    <div id="shop">
      <button id="buyTractorBtn">Buy ðŸšœ Tractor (2000)</button>
      <button id="buyHarvesterBtn">Buy ðŸ§º Harvester (3500)</button>
      <button id="buySprayerBtn">Buy ðŸ§´ Sprayer (2500)</button>
      <button id="buyWagonBtn">Buy ðŸ›’ Tractor Wagon (1200)</button>
      <button id="buySemiBtn">Buy ðŸšš Semi-truck (5000)</button>
    </div>
  </div>

  <aside id="sidebar">
    <section id="tileInfo">
      <h2>Tile Info</h2>
      <div class="kv" id="tileKV"></div>
    </section>
    <section id="unitList">
      <h2>Machines & Queues</h2>
      <div id="unitCards"></div>
    </section>
    <section id="debug">
      <h2>Debug / Tests</h2>
      <div id="testResults" style="font-size:.9rem;"></div>
      <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
        <button id="runTestsBtn" class="tiny secondary">Run tests</button>
      </div>
    </section>
  </aside>

  <details open>
    <summary>How to play</summary>
    <ul>
      <li><b>H = Farm Hub</b> â€” high-contrast tile(s) where <b>new equipment spawns</b>.</li>
      <li><b>Left-click</b> a tile for info or a unit to select it. <b>Right-click</b> to issue an order. <b>Shift+Right-click</b> queues.</li>
      <li>Use the mouse wheel to <b>zoom</b>. Middle-drag (or hold <b>Alt</b> + left-drag) to <b>pan</b> the map.</li>
      <li>Start by creating fields (mode = <b>Field</b>, use a Tractor on grass). Then <b>Plow â†’ Seed â†’ Spray â†’ Harvest</b>.</li>
      <li>Spray early/mid Growing for a bonus. Ready crops decay if ignored.</li>
      <li>Auto-save is enabled. Use <b>Reset Farm</b> to wipe progress.</li>
      <li><b>Seasons</b>: Spring â†’ Summer â†’ Autumn â†’ Winter (<b>4 days each</b>). Winter is dormant for crops, but you can <b>Snowplow</b> roads/fields.</li>
      <li><b>Shifts</b>: Workers operate <b>10 in-game hours/day</b> (08:00â€“18:00). Outside shift they rest.</li>
      <li><b>Balance</b>: 1Ã— Tractor + 1Ã— Sprayer + 1Ã— Harvester can maintain ~50 field tiles if you stagger tasks; 2Ã— of each â‰ˆ 100 tiles, etc.</li>
      <li><b>Stone picking</b> (Tractor): do it on a field before seeding to get a small harvest bonus.</li>
    </ul>
  </details>

  <div id="boardWrap">
    <div id="gameContainer">
      <canvas id="game" width="704" height="448"></canvas>
    </div>
  </div>

<script>
'use strict';
/* ==================================
   Grid safety + bounds helpers first
   ================================== */
const TILE_SIZE = 33;
const GRID_W = 60;
const GRID_H = 40;

function inBounds(x,y){ return x>=0 && y>=0 && x<GRID_W && y<GRID_H; }
function getCell(grid,x,y,def){ const row = grid[y]; if(!row) return def; const v = row[x]; return (v===undefined)? def : v; }
function setCell(grid,x,y,val){ if(!grid[y]) grid[y]=[]; grid[y][x]=val; }
function ensureGridDims(){
  const grids = [tiles,crops,cropTimers,readyTimers,sprayed,snow,stonePicked];
  for(const g of grids){
    for(let y=0;y<GRID_H;y++){
      if(!g[y]) g[y]=[];
      for(let x=0;x<GRID_W;x++){
        if(g===tiles && g[y][x]===undefined) g[y][x]=TileType.GRASS;
        if(g===crops && g[y][x]===undefined) g[y][x]=CROP_STAGE.NONE;
        if(g===cropTimers && g[y][x]===undefined) g[y][x]=0;
        if(g===readyTimers && g[y][x]===undefined) g[y][x]=0;
        if(g===sprayed && g[y][x]===undefined) g[y][x]=false;
        if(g===snow && g[y][x]===undefined) g[y][x]=false;
        if(g===stonePicked && g[y][x]===undefined) g[y][x]=false;
      }
    }
  }
}

/* ===== Game constants ===== */
const TileType = { GRASS:0, FIELD:1, ROAD:2, SILO:3, HOUSE:4, ELEVATOR:5 };
const CROP_STAGE = { NONE:-1, BARE:0, PLOWED:1, GROWING:2, READY:3 };

const ACTION = { MOVE:'move', FIELD:'field', PLOW:'plow', SEED:'seed', SPRAY:'spray', HARVEST:'harvest', STONE:'stone', SNOW:'snow', LOAD:'load', UNLOAD:'unload', SELL:'sell', AUTO:'auto' };

const IDLE_TO_ROAD_MINUTES = 30;          // After 30 idle minutes, seek a road spot
const IDLE_TO_SHELTER_MINUTES = 60;       // After 60 idle minutes on a road, seek a house

// ===== Seasons =====
const SEASONS = ['Spring','Summer','Autumn','Winter'];
const DAYS_PER_SEASON = 4;                 // 4 days per season (humane length)
const MINUTES_PER_DAY = 24*60;             // in-game minutes per day
const REAL_SECONDS_PER_INGAME_DAY = 300;   // 5 real min per in-game day

// ===== Shifts =====
const SHIFT_START_H = 6;                   // 06:00
const SHIFT_END_H   = 22;                  // 22:00
const SHIFT_FRACTION = (SHIFT_END_H - SHIFT_START_H) / 24;
const SHIFT_SECONDS_PER_INGAME_DAY = REAL_SECONDS_PER_INGAME_DAY * SHIFT_FRACTION;

function seasonFromMinutes(totalMinutes){
  const dayAbs = Math.floor(totalMinutes / MINUTES_PER_DAY);
  const year = 1 + Math.floor(dayAbs / (DAYS_PER_SEASON*SEASONS.length));
  const dayInYear = dayAbs % (DAYS_PER_SEASON*SEASONS.length);
  const seasonIndex = Math.floor(dayInYear / DAYS_PER_SEASON);
  const dayInSeason = 1 + (dayInYear % DAYS_PER_SEASON);
  return {year, seasonIndex, seasonName: SEASONS[seasonIndex], dayInSeason};
}
function seasonGrowthMult(seasonIndex){ return [1.0, 1.25, 0.8, 0.0][seasonIndex]; }
function seasonDecayMult(seasonIndex){ return [1.0, 1.0, 1.0, 1.5][seasonIndex]; }
function winterHarvestPenalty(seasonIndex){ return (seasonIndex===3) ? 0.8 : 1.0; }

const FIELDIFY_TIME = 2; let FIELDIFY_COST = 60;
// Action times tuned so a single unit can finish ~50 tiles within one 10h shift
let PLOW_TIME = 2.5;
let SEED_TIME = 2.5;
let SPRAY_TIME = 2.5;
let HARVEST_TIME = 2.5;
let STONE_TIME = 2.5;   // pre-seeding QoL
let SNOW_TIME = 2.0;    // winter activity

const GROWTH_TIME = 1200;      // â‰ˆ2 in-game days seed â†’ ready
const READY_WINDOW = 300;     // â‰ˆ1 in-game day to harvest
const SPRAY_BEST_FROM = 0.15; const SPRAY_BEST_TO = 0.75;

let MOVE_DELAY = 0.25;  // responsive
let BASE_VALUE = 140; let BONUS_VALUE = 210; // spray bonus
const STONE_BONUS_MULT = 1.1; // harvest +10% if stone-picked
const SNOWPLOW_PAY = 5;       // small income per snow tile cleared

const COST = { TRACTOR:2000, HARVESTER:3500, SPRAYER:2500, WAGON:1200, SEMI:5000 };

const GRAIN_PER_TILE = 120;
const HARVESTER_CAPACITY = 600;
const WAGON_CAPACITY = 900;
const SEMI_CAPACITY = 2400;
const TRANSFER_TIME = 2.0;
const FRESH_MULT = 0.9;
const DRY_MULT = 1.25;
const DRY_TIME = 600; // minutes in silo to be considered dry




/* ===== Map ===== */
const baseRows = [
  "ggggggggggggggggggggggggggggggggggggggggggggggggggggggggggrE",
  "ggggggggggggggggggggggggggggggggggggggggggggggggggggggggggrr",
  "gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggr",
  "rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr",
  "ggggggggggggrggggggggggggggggggggggggggggggggggggggggggggggg",
  "ggggggggggggrggggggggggggggggggggggggggggggggggggggggggggggg",
  "ggggggggggggrggggggggggggggggggggggggggggggggggggggggggggggg",
  "ggggggggHHHHrggggggggggggggggggggggggggggggggggggggggggggggg",
  "ggggggggHHHHrggggggggggggggggggggggggggggggggggggggggggggggg",
  "ggggrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrggggggggggggggggggg",
  "ggggggggSgSgrgggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggrgggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggrgggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggrgggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggrgggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggrgggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "ggggggggggggggggggggggggggggggggggggggggrggggggggggggggggggg",
  "gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg",
  "gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg",
  "gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg",
];

/* ===== State ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const moneySpan = document.getElementById('money');
const daySpan = document.getElementById('day');
const timeSpan = document.getElementById('time');
const seasonLabel = document.getElementById('season');
const shiftLabel = document.getElementById('shift');
const pauseBtn = document.getElementById('pauseBtn');
const speed1Btn = document.getElementById('speed1Btn');
const speed3Btn = document.getElementById('speed3Btn');
const resetBtn = document.getElementById('resetBtn');
const sleepBtn = document.getElementById('sleepBtn');
const presetSel = document.getElementById('preset');
const planBtn = document.getElementById('planBtn');
const planScopeWrap = document.getElementById('planScopeWrap');
const planScopeSel = document.getElementById('planScope');
const buyTractorBtn = document.getElementById('buyTractorBtn');
const buyHarvesterBtn = document.getElementById('buyHarvesterBtn');
const buySprayerBtn = document.getElementById('buySprayerBtn');
const buyWagonBtn = document.getElementById('buyWagonBtn');
const buySemiBtn = document.getElementById('buySemiBtn');
const unitListEl = document.getElementById('unitList');
const unitCardsEl = document.getElementById('unitCards');
const tileKV = document.getElementById('tileKV');
const runTestsBtn = document.getElementById('runTestsBtn');
const testResults = document.getElementById('testResults');

const boardWrap = document.getElementById('boardWrap');
const gameContainer = document.getElementById('gameContainer');
const howToDetails = document.querySelector('details');
const modeBar = document.getElementById('modes');
let currentMode = ACTION.AUTO;

canvas.width = GRID_W * TILE_SIZE;
canvas.height = GRID_H * TILE_SIZE;

const WORLD_W = GRID_W * TILE_SIZE;
const WORLD_H = GRID_H * TILE_SIZE;

let viewScale = 1;
let viewOffsetX = 0;
let viewOffsetY = 0;
const MIN_VIEW_SCALE = 0.6;
const MAX_VIEW_SCALE = 2.5;

let tiles = [], crops = [], cropTimers = [], readyTimers = [], sprayed = [];
let snow = [], stonePicked = [];
let siloTiles = [];
let elevatorTile = [];
let siloStorage = [];

function siloReadyGrain(){
  let amt=0;
  for(const lot of siloStorage){ if(gameMinutes - lot.storedAt >= DRY_TIME) amt += lot.amount; }
  return amt;
}
function storeInSilo(amount){ if(amount>0) siloStorage.push({amount, storedAt:gameMinutes}); }
function takeFromSilo(amount){
  let remaining = amount, taken=0;
  for(const lot of siloStorage){
    if(gameMinutes - lot.storedAt < DRY_TIME) continue;
    const take = Math.min(lot.amount, remaining);
    lot.amount -= take; remaining -= take; taken += take;
    if(remaining<=0) break;
  }
  siloStorage = siloStorage.filter(l=>l.amount>0);
  return taken;
}
let selectedTile = {x: 0, y: 0};

let lastSeasonIndex = 0;

/* Hub helpers */
function getHubTiles(){ const list=[]; for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(baseRows[y][x]==='H') list.push({x,y}); return list; }
function getHubSpawn(){ const hs=getHubTiles(); if(!hs.length) return {x:4,y:7}; const avgX=Math.round(hs.reduce((a,c)=>a+c.x,0)/hs.length), avgY=Math.round(hs.reduce((a,c)=>a+c.y,0)/hs.length); let best=hs[0],d=1e9; for(const h of hs){const dd=Math.abs(h.x-avgX)+Math.abs(h.y-avgY); if(dd<d){d=dd; best=h;}} return best; }

function initMap(newGame=false){
  siloStorage = [];
  for(let y=0;y<GRID_H;y++){
    tiles[y]=[]; crops[y]=[]; cropTimers[y]=[]; readyTimers[y]=[]; sprayed[y]=[]; snow[y]=[]; stonePicked[y]=[];
    for(let x=0;x<GRID_W;x++){
      const row = baseRows[y] || '';
      const ch  = row[x] || 'g';   // 'g' = grass
      let t = TileType.GRASS; if(ch==='r') t=TileType.ROAD; else if(ch==='S') t=TileType.SILO; else if(ch==='H') t=TileType.HOUSE; else if (ch === 'E') t = TileType.ELEVATOR;
      tiles[y][x]=t; crops[y][x]=CROP_STAGE.NONE; cropTimers[y][x]=0; readyTimers[y][x]=0; sprayed[y][x]=false; stonePicked[y][x]=false; snow[y][x]=false;
    }
  }
  rebuildSiloListsFromTiles();
  if(newGame){ const hub=getHubSpawn(); const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}]; for(const d of dirs){const nx=hub.x+d.dx, ny=hub.y+d.dy; if(inBounds(nx,ny) && tiles[ny][nx]===TileType.GRASS){ tiles[ny][nx]=TileType.FIELD; crops[ny][nx]=CROP_STAGE.BARE; break; }} }
  ensureGridDims();
}

function rebuildSiloListsFromTiles(){
  siloTiles = [];
  elevatorTile = null;
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      if(tiles[y][x]===TileType.SILO) siloTiles.push({x,y});
      if(tiles[y][x]===TileType.ELEVATOR) elevatorTile = {x,y};
    }
  }
  if(!elevatorTile && siloTiles.length>1){
    elevatorTile = siloTiles.pop();
    tiles[elevatorTile.y][elevatorTile.x] = TileType.ELEVATOR;
  }
}

/* ===== Units ===== */
const UnitType = { TRACTOR:'Tractor', HARVESTER:'Harvester', SPRAYER:'Sprayer', WAGON:'Tractor Wagon', SEMI:'Semi-truck' };
const units = []; let nextUnitId = 1; let selectedUnit = 0;

let unitListDirty = false;
function markUnitListDirty(){ unitListDirty = true; }
function updateUnitState(u, newState){ if(u.state!==newState){ u.state = newState; markUnitListDirty(); } }
function setRestTarget(u, target){
  const prev = u.restTarget;
  if(prev && target){
    if(prev.x===target.x && prev.y===target.y && prev.kind===target.kind){ u.restTarget = target; return; }
  }
  if(!prev && !target) return;
  u.restTarget = target ?? null;
  markUnitListDirty();
}
function clearRestTarget(u){ if(u.restTarget){ u.restTarget = null; markUnitListDirty(); } else if(u.restTarget!==null){ u.restTarget = null; } }

function capacityFor(type){
  if(type===UnitType.HARVESTER) return HARVESTER_CAPACITY;
  if(type===UnitType.WAGON) return WAGON_CAPACITY;
  if(type===UnitType.SEMI) return SEMI_CAPACITY;
  return 0;
}

function createUnit(type,x,y,opts={}){
  return {
    id: nextUnitId++,
    type,
    x,
    y,
    moveCooldown:0,
    path:null,
    pathTarget:null,
    commands:[],
    action:null,
    actionTimer:0,
    workX:null,
    workY:null,
    state:'idle',
    isOwner: !!opts.isOwner,
    alwaysActive: !!opts.alwaysActive,
    idleMinutes:0,
    restTarget:null,
    cargo:0,
    cargoKind:null,
    capacity: capacityFor(type),
    lastShiftState: opts.alwaysActive ? true : withinShift(),
    hitchedTo: null
  };
}
function initUnits(){
  units.length=0;
  const hub=getHubSpawn();
  units.push(createUnit(UnitType.TRACTOR, hub.x, hub.y, {isOwner:true, alwaysActive:true}));
  selectedUnit=0;
}

function unitCanDo(unit, action){
  if(action===ACTION.MOVE || action===ACTION.AUTO) return true;
  if(unit.type===UnitType.TRACTOR) return (action===ACTION.FIELD || action===ACTION.PLOW || action===ACTION.SEED || action===ACTION.STONE || action===ACTION.SNOW);
  if(unit.type===UnitType.HARVESTER) return (action===ACTION.HARVEST || action===ACTION.UNLOAD);
  if(unit.type===UnitType.SPRAYER) return (action===ACTION.SPRAY);
  if(unit.type===UnitType.WAGON || unit.type===UnitType.SEMI) return (action===ACTION.LOAD || action===ACTION.UNLOAD || action===ACTION.SELL);
  return false;
}

/* ===== Time & Economy ===== */
let money = 7000; let gameMinutes = 8*60; let paused=false; let timeScale=1;

function withinShift(){ const minuteInDay=Math.floor(gameMinutes%MINUTES_PER_DAY); const hour=Math.floor(minuteInDay/60); return (hour>=SHIFT_START_H && hour<SHIFT_END_H); }
function unitIsOnShift(u){ return u && u.alwaysActive ? true : withinShift(); }

function refreshHud(seasonInfo){
  const minutesPerDay = MINUTES_PER_DAY;
  const day = 1 + Math.floor(gameMinutes/minutesPerDay);
  const minuteInDay = Math.floor(gameMinutes%minutesPerDay);
  const hour = Math.floor(minuteInDay/60);
  const minute = minuteInDay%60;
  if(daySpan) daySpan.textContent = String(day);
  if(timeSpan) timeSpan.textContent = `${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}`;
  const s = seasonInfo ?? seasonFromMinutes(gameMinutes);
  if(seasonLabel) seasonLabel.textContent = `${s.seasonName}, Day ${s.dayInSeason}`;
  if(shiftLabel) shiftLabel.textContent = withinShift()? 'On' : 'Off';
}

function updateGameClock(dt, opts={}){
  const skipHud = opts.skipHud ?? false;
  const simDt = dt * timeScale;
  const minutesPerRealSecond = MINUTES_PER_DAY / REAL_SECONDS_PER_INGAME_DAY;
  gameMinutes += simDt * minutesPerRealSecond;
  const s = seasonFromMinutes(gameMinutes);
  if(s.seasonIndex!==lastSeasonIndex){ onSeasonChanged(lastSeasonIndex, s.seasonIndex); lastSeasonIndex = s.seasonIndex; }
  if(!skipHud) refreshHud(s);
}

function onSeasonChanged(prev, now){
  // When Winter starts, blanket snow over roads, fields & grass (but not buildings).
  if(now===3){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const t = tiles[y][x];
        if(t===TileType.ROAD || t===TileType.FIELD || t===TileType.GRASS){
          snow[y][x] = true;
        }
      }
    }
  }
  // Optional: melt on Spring
  if(prev===3 && now===0){ for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) snow[y][x]=false; }
}

/* ===== Crops ===== */
function updateCrops(dt){
  const s = seasonFromMinutes(gameMinutes);
  const growMult = seasonGrowthMult(s.seasonIndex);
  const decayMult = seasonDecayMult(s.seasonIndex);
  const simDt = dt*timeScale;
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      const stage = crops[y][x];
      if(stage===CROP_STAGE.GROWING){
        cropTimers[y][x]+=simDt*growMult;
        if(cropTimers[y][x]>=GROWTH_TIME){ crops[y][x]=CROP_STAGE.READY; readyTimers[y][x]=0; cropTimers[y][x]=0; }
      } else if(stage===CROP_STAGE.READY){
        readyTimers[y][x]+=simDt*decayMult;
        if(readyTimers[y][x]>=READY_WINDOW){ crops[y][x]=CROP_STAGE.BARE; sprayed[y][x]=false; readyTimers[y][x]=0; stonePicked[y][x]=false; }
      }
    }
  }
}

function growthProgress(x,y){ return getCell(crops,x,y,CROP_STAGE.NONE)===CROP_STAGE.GROWING ? Math.max(0, Math.min(1, getCell(cropTimers,x,y,0) / GROWTH_TIME)) : 0; }
function readyProgress(x,y){ return getCell(crops,x,y,CROP_STAGE.NONE)===CROP_STAGE.READY ? Math.max(0, Math.min(1, getCell(readyTimers,x,y,0) / READY_WINDOW)) : 0; }

/* ===== Commands ===== */
function isOccupied(x,y, ignoreUnit){
  for(const other of units){
    if(!other || other===ignoreUnit) continue;
    if(other.x===x && other.y===y) return true;
  }
  return false;
}

function findAdjacentTractor(u){
  if(!u) return null;
  for(const other of units){
    if(!other || other.type!==UnitType.TRACTOR) continue;
    const dist = Math.abs(other.x - u.x) + Math.abs(other.y - u.y);
    if(dist===1) return other;
  }
  return null;
}

function unitHasTowPower(u){
  if(!u || u.type!==UnitType.WAGON) return true;
  const tractor = findAdjacentTractor(u);
  if(!tractor){ u.hitchedTo=null; return false; }
  u.hitchedTo = tractor.id;
  if(tractor.actionTimer>0) return false;
  return true;
}

function restKindsMatch(a,b){
  if(a===b) return true;
  if(a==='house' && b==='shelter') return true;
  if(a==='shelter' && b==='house') return true;
  return false;
}

function isTileReserved(x,y, kind, ignoreUnit){
  for(const other of units){
    if(!other || other===ignoreUnit) continue;
    const target = other.restTarget;
    if(target && target.x===x && target.y===y){
      if(!kind || !target.kind || restKindsMatch(kind, target.kind)) return true;
    }
    if(other.commands){
      for(const cmd of other.commands){
        if(cmd.meta==='rest' && cmd.tx===x && cmd.ty===y){
          const restKind = cmd.restKind || null;
          if(!kind || !restKind || restKindsMatch(kind, restKind)) return true;
        }
      }
    }
  }
  return false;
}

function tileMovementCost(x, y){
  const tile = getTile(x, y);
  if(tile===TileType.ROAD) return 1;
  return 2;
}

function isWalkableForUnit(u, x, y, tx, ty){
  if(!inBounds(x, y)) return false;
  const tile = getTile(x, y);
  if(tile===TileType.SILO && !(x===tx && y===ty)) return false;
  return true;
}

function reconstructPath(cameFrom, currentKey){
  const path = [];
  let key = currentKey;
  while(cameFrom.has(key)){
    const [px, py] = key.split(',').map(Number);
    path.push({x:px, y:py});
    key = cameFrom.get(key);
  }
  path.reverse();
  return path;
}

function computePath(u, tx, ty){
  if(!inBounds(tx, ty)) return null;
  if(u.x===tx && u.y===ty) return [];
  const startKey = `${u.x},${u.y}`;
  const goalKey = `${tx},${ty}`;
  const openList = [startKey];
  const openSet = new Set([startKey]);
  const closedSet = new Set();
  const cameFrom = new Map();
  const gScore = new Map();
  gScore.set(startKey, 0);
  const fScore = new Map();
  fScore.set(startKey, Math.abs(u.x-tx) + Math.abs(u.y-ty));

  while(openList.length){
    let currentIndex = 0;
    let currentKey = openList[0];
    let bestScore = fScore.get(currentKey) ?? Infinity;
    for(let i=1;i<openList.length;i++){
      const key = openList[i];
      const score = fScore.get(key) ?? Infinity;
      if(score < bestScore){
        bestScore = score;
        currentKey = key;
        currentIndex = i;
      }
    }

    const [cx, cy] = currentKey.split(',').map(Number);
    if(currentKey===goalKey) return reconstructPath(cameFrom, currentKey);

    openList.splice(currentIndex, 1);
    openSet.delete(currentKey);
    closedSet.add(currentKey);

    const neighbors = [
      {x:cx+1, y:cy},
      {x:cx-1, y:cy},
      {x:cx, y:cy+1},
      {x:cx, y:cy-1}
    ];

    for(const nb of neighbors){
      if(!isWalkableForUnit(u, nb.x, nb.y, tx, ty)) continue;
      const nbKey = `${nb.x},${nb.y}`;
      if(closedSet.has(nbKey)) continue;
      if(isOccupied(nb.x, nb.y, u) && !(nb.x===tx && nb.y===ty)) continue;

      const tentativeG = (gScore.get(currentKey) ?? Infinity) + tileMovementCost(nb.x, nb.y);
      if(tentativeG >= (gScore.get(nbKey) ?? Infinity)) continue;

      cameFrom.set(nbKey, currentKey);
      gScore.set(nbKey, tentativeG);
      const heuristic = Math.abs(nb.x - tx) + Math.abs(nb.y - ty);
      fScore.set(nbKey, tentativeG + heuristic);
      if(!openSet.has(nbKey)){
        openSet.add(nbKey);
        openList.push(nbKey);
      }
    }
  }

  return null;
}

function clearUnitPath(u){
  u.path = null;
  u.pathTarget = null;
}

function ensureUnitPath(u, tx, ty){
  const targetMatches = u.pathTarget && u.pathTarget.x===tx && u.pathTarget.y===ty;
  if(!targetMatches){
    u.path = computePath(u, tx, ty);
  } else if(Array.isArray(u.path)){
    if(u.path.length){
      const next = u.path[0];
      if(Math.abs(next.x - u.x) + Math.abs(next.y - u.y) !== 1){
        u.path = computePath(u, tx, ty);
      }
    } else if(u.x!==tx || u.y!==ty){
      u.path = computePath(u, tx, ty);
    }
  } else {
    u.path = computePath(u, tx, ty);
  }

  if(!u.pathTarget){
    u.pathTarget = {x:tx, y:ty};
  } else {
    u.pathTarget.x = tx;
    u.pathTarget.y = ty;
  }
  return u.path;
}

function findNearestTileOfType(u, tileTypes, opts={}){
  const allowOccupied = opts.allowOccupied ?? false;
  const avoidReserved = opts.avoidReserved ?? false;
  const reserveKind = opts.reserveKind ?? null;
  let best = null;
  let bestDist = Infinity;
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      if(!tileTypes.has(tiles[y][x])) continue;
      if(!allowOccupied && isOccupied(x,y,u)){
        if(!(u.x===x && u.y===y)) continue;
      }
      if(avoidReserved && !(u.x===x && u.y===y) && isTileReserved(x,y, reserveKind, u)) continue;
      const dist = Math.abs(u.x-x) + Math.abs(u.y-y);
      if(dist < bestDist){ bestDist = dist; best = {x,y}; }
    }
  }
  return best;
}

function findNearestRoad(u, opts={}){
  return findNearestTileOfType(u, new Set([TileType.ROAD]), opts);
}

function findNearestHouse(u, opts={}){
  return findNearestTileOfType(u, new Set([TileType.HOUSE]), opts);
}

function findNearestSilo(u, opts={}){
  return findNearestTileOfType(u, new Set([TileType.SILO]), opts);
}

function findElevatorTile(){ return elevatorTile; }

function findParkingNearHouse(house, u){
  if(!house) return null;
  const maxDist = 8;
  const visited = new Set();
  const queue = [{x:house.x, y:house.y, dist:0}];
  visited.add(`${house.x},${house.y}`);
  while(queue.length){
    const current = queue.shift();
    if(current.dist >= maxDist) continue;
    const nextDist = current.dist + 1;
    const neighbors = [
      {x:current.x+1, y:current.y},
      {x:current.x-1, y:current.y},
      {x:current.x, y:current.y+1},
      {x:current.x, y:current.y-1}
    ];
    for(const nb of neighbors){
      const key = `${nb.x},${nb.y}`;
      if(visited.has(key)) continue;
      visited.add(key);
      if(!inBounds(nb.x, nb.y)) continue;
      const tile = getTile(nb.x, nb.y);
      if(tile===TileType.SILO || tile===TileType.HOUSE) continue;
      const open = !isOccupied(nb.x, nb.y, u) && !isTileReserved(nb.x, nb.y, 'shelter', u);
      if(open) return nb;
      queue.push({x:nb.x, y:nb.y, dist:nextDist});
    }
  }
  return null;
}

function sendUnitHome(u){
  if(!u || u.alwaysActive) return false;
  const hereTile = getTile(u.x, u.y);
  if(hereTile===TileType.HOUSE && !isOccupied(u.x, u.y, u)){
    setRestTarget(u, {x:u.x, y:u.y, kind:'house'});
    return true;
  }
  removeRestCommands(u);
  clearRestTarget(u);
  const preferredHouse = findNearestHouse(u, {avoidReserved:true, reserveKind:'house'});
  if(preferredHouse && !isOccupied(preferredHouse.x, preferredHouse.y, u)){
    enqueueCommand(u, {tx:preferredHouse.x, ty:preferredHouse.y, type:ACTION.MOVE, meta:'rest', restKind:'house'});
    return true;
  }
  const fallbackHouse = preferredHouse || findNearestHouse(u, {avoidReserved:false});
  if(fallbackHouse){
    const parking = findParkingNearHouse(fallbackHouse, u);
    if(parking){
      enqueueCommand(u, {tx:parking.x, ty:parking.y, type:ACTION.MOVE, meta:'rest', restKind:'shelter'});
      return true;
    }
  }
  return false;
}

function handleShiftEnded(u){
  if(!u || u.alwaysActive) return;

  // Cancel any ongoing work
  if(u.actionTimer > 0){
    u.actionTimer = 0;
    u.action = null;
    u.workX = null;
    u.workY = null;
  }

  // Go idle and reset movement
  updateUnitState(u, 'idle');
  u.moveCooldown = 0;

  // Clear queue + path + rest target
  if(u.commands.length){
    u.commands.length = 0;
    markUnitListDirty();
  }
  clearUnitPath(u);
  clearRestTarget(u);

  // Consider them "due" for parking/shelter so sendUnitHome will actually do something
  u.idleMinutes = Math.max(u.idleMinutes ?? 0, IDLE_TO_SHELTER_MINUTES);

  // Enqueue a rest move (house/road) if possible
  sendUnitHome(u);
}

function getTile(x,y){ return inBounds(x,y) ? tiles[y][x] : null; }
function getStage(x,y){ return inBounds(x,y) ? crops[y][x] : CROP_STAGE.NONE; }
function getSnow(x,y){ return inBounds(x,y) ? snow[y][x] : false; }
function getSprayed(x,y){ return inBounds(x,y) ? sprayed[y][x] : false; }
function getStone(x,y){ return inBounds(x,y) ? stonePicked[y][x] : false; }

function autoPickActionForTile(unit, tx, ty){
  if(!inBounds(tx,ty)) return null;
  const t = getTile(tx,ty); const s = seasonFromMinutes(gameMinutes);
  if(unit.type===UnitType.TRACTOR){
    if(s.seasonIndex===3){
      if(getSnow(tx,ty)){
        if(t===TileType.ROAD || t===TileType.FIELD || t===TileType.GRASS) return ACTION.SNOW;
      }
      return null;
    }
    if(t===TileType.GRASS) return ACTION.FIELD;
    if(t!==TileType.FIELD) return null;
    const stage = getStage(tx,ty);
    if(stage===CROP_STAGE.BARE && !getStone(tx,ty)) return ACTION.STONE; // optional
    if(stage===CROP_STAGE.BARE) return ACTION.PLOW;
    if(stage===CROP_STAGE.PLOWED) return ACTION.SEED;
  }
  if(unit.type===UnitType.SPRAYER){ if(t===TileType.FIELD && getStage(tx,ty)===CROP_STAGE.GROWING) return ACTION.SPRAY; }
  if(unit.type===UnitType.HARVESTER){ if(t===TileType.FIELD && getStage(tx,ty)===CROP_STAGE.READY) return ACTION.HARVEST; }
  if(unit.type===UnitType.WAGON || unit.type===UnitType.SEMI){
    const harvester = units.find(o=>o && o.type===UnitType.HARVESTER && o.x===tx && o.y===ty && o.cargo>0);
    if(harvester && unit.cargo < unit.capacity) return ACTION.LOAD;
    if((t===TileType.SILO || t===TileType.ELEVATOR) && unit.cargo>0){ return t===TileType.ELEVATOR? ACTION.SELL : ACTION.UNLOAD; }
  }
  return null;
}

function tryStartWork(u, tx, ty, action){
  if(!inBounds(tx,ty)) return false;
  const tile = getTile(tx,ty);
  if(action===ACTION.MOVE) return false;

  // Respect shift hours
  if(!unitIsOnShift(u)) return false;

  let chosen = action===ACTION.AUTO ? autoPickActionForTile(u, tx, ty) : action;
  if(!chosen) return false; if(!unitCanDo(u, chosen)) return false;

  clearRestTarget(u);

  if(action===ACTION.LOAD){
    if(u.loadFrom==='silo'){
      const available = siloReadyGrain();
      if(available<=0 || u.cargo>=u.capacity) return false;
      u.action = ACTION.LOAD; u.actionTimer = TRANSFER_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); return true;
    }
    const donor = units.find(o=>o && o.x===tx && o.y===ty && o.id===u.loadTargetId);
    if(!donor || donor.cargo<=0 || u.cargo>=u.capacity) return false;
    u.action = ACTION.LOAD; u.actionTimer = TRANSFER_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); return true;
  }
  if(action===ACTION.UNLOAD){
    if(u.cargo<=0) return false;
    if(tile!==TileType.SILO) return false;
    u.action = ACTION.UNLOAD; u.actionTimer = TRANSFER_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); return true;
  }
  if(action===ACTION.SELL){
    if(u.cargo<=0) return false;
    if(tile!==TileType.ELEVATOR) return false;
    u.action = ACTION.SELL; u.actionTimer = TRANSFER_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); return true;
  }

  // Field creation
  if(chosen===ACTION.FIELD){ if(tile!==TileType.GRASS) return false; if(money < FIELDIFY_COST) return false; u.action=ACTION.FIELD; u.actionTimer=FIELDIFY_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); money-=FIELDIFY_COST; return true; }

  // Stone picking (before seeding)
  if(chosen===ACTION.STONE){ if(tile!==TileType.FIELD) return false; const st=getStage(tx,ty); if(!(st===CROP_STAGE.BARE || st===CROP_STAGE.PLOWED)) return false; if(getStone(tx,ty)) return false; u.action=ACTION.STONE; u.actionTimer=STONE_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); return true; }

  // Snow plow (Winter)
  if(chosen===ACTION.SNOW){ const s=seasonFromMinutes(gameMinutes); if(s.seasonIndex!==3) return false; if(!(tile===TileType.ROAD||tile===TileType.FIELD||tile===TileType.GRASS)) return false; if(!getSnow(tx,ty)) return false; u.action=ACTION.SNOW; u.actionTimer=SNOW_TIME; u.workX=tx; u.workY=ty; updateUnitState(u,'working'); return true; }

  // Farm actions need a field
  if(tile!==TileType.FIELD) return false;
  const stage = getStage(tx,ty); let dur = 0;
  if(chosen===ACTION.HARVEST && u.cargo>=u.capacity) return false;
  if(chosen===ACTION.PLOW && stage===CROP_STAGE.BARE) dur=PLOW_TIME;
  else if(chosen===ACTION.SEED && stage===CROP_STAGE.PLOWED){ const s=seasonFromMinutes(gameMinutes); if(s.seasonIndex===3) return false; dur=SEED_TIME; }
  else if(chosen===ACTION.SPRAY && stage===CROP_STAGE.GROWING) dur=SPRAY_TIME;
  else if(chosen===ACTION.HARVEST && stage===CROP_STAGE.READY) dur=HARVEST_TIME;
  else return false;

  u.action = chosen; u.actionTimer = dur; u.workX = tx; u.workY = ty; updateUnitState(u,'working');
  return true;
}

function enqueueCommand(u, cmd){
  if(!cmd) return;
  if(cmd.meta==='rest'){
    setRestTarget(u, {x:cmd.tx, y:cmd.ty, kind:cmd.restKind || 'road'});
  } else {
    removeRestCommands(u);
    clearRestTarget(u);
    u.idleMinutes = 0;
  }
  u.commands.push(cmd);
  markUnitListDirty();
}

function removeRestCommands(u){
  if (!u || !u.commands) return false;

  let removed = false;

  // Remove all rest-commands from the end of the queue
  for (let i = u.commands.length - 1; i >= 0; i--) {
    if (u.commands[i].meta === 'rest') {
      u.commands.splice(i, 1);
      removed = true;
    }
  }

  if (removed) {
    // Sidebar queue changed
    markUnitListDirty();

    // If queue is now empty, or first cmd no longer matches pathTarget,
    // the cached path is stale â†’ clear it.
    if (
      u.commands.length === 0 ||
      (u.pathTarget &&
       u.commands[0] &&
       (u.pathTarget.x !== u.commands[0].tx ||
        u.pathTarget.y !== u.commands[0].ty))
    ){
      clearUnitPath(u);
    }
  }

  return removed;
}

function harvestersNeedingUnload(){
  return units.filter(o=>o && o.type===UnitType.HARVESTER && o.cargo>0);
}

function findNearestHarvesterWithCargo(u){
  let best=null, bestDist=Infinity;
  for(const h of harvestersNeedingUnload()){
    const dist=Math.abs(h.x-u.x)+Math.abs(h.y-u.y);
    if(dist<bestDist){ best=h; bestDist=dist; }
  }
  return best;
}

function planHauler(u){
  if(!u || (u.type!==UnitType.WAGON && u.type!==UnitType.SEMI)) return;
  if(u.actionTimer>0 || u.commands.some(c=>c.meta!=='rest')) return;

  if(u.cargo>0){
    const drop = (u.cargoKind==='fresh') ? findNearestSilo(u,{allowOccupied:true}) : findElevatorTile() || findNearestSilo(u,{allowOccupied:true});
    const action = (drop && tiles[drop.y][drop.x]===TileType.ELEVATOR) ? ACTION.SELL : ACTION.UNLOAD;
    if(drop){
      enqueueCommand(u,{tx:drop.x, ty:drop.y, type:ACTION.MOVE});
      enqueueCommand(u,{tx:drop.x, ty:drop.y, type:action});
      return;
    }
  }

  const siloGrain = siloReadyGrain();
  if(siloGrain>0 && elevatorTile){
    const silo = findNearestSilo(u,{allowOccupied:true});
    if(silo){
      u.loadFrom='silo';
      enqueueCommand(u,{tx:silo.x, ty:silo.y, type:ACTION.MOVE});
      enqueueCommand(u,{tx:silo.x, ty:silo.y, type:ACTION.LOAD});
      enqueueCommand(u,{tx:elevatorTile.x, ty:elevatorTile.y, type:ACTION.MOVE});
      enqueueCommand(u,{tx:elevatorTile.x, ty:elevatorTile.y, type:ACTION.SELL});
      return;
    }
  }

  const har = findNearestHarvesterWithCargo(u);
  if(har){
    u.loadFrom='harvester';
    u.loadTargetId = har.id;
    enqueueCommand(u,{tx:har.x, ty:har.y, type:ACTION.MOVE});
    enqueueCommand(u,{tx:har.x, ty:har.y, type:ACTION.LOAD});
    return;
  }
}

function maybeSendToRest(u){
  if(!u) return;
  if(u.actionTimer>0) return;
  if(u.commands.some(c=>c.meta!=='rest')) return;

  const hereTile = getTile(u.x, u.y);
  if(hereTile===TileType.HOUSE){
    setRestTarget(u, {x:u.x, y:u.y, kind:'house'});
    return;
  }

  const headingToHouse = u.commands.some(c=>c.meta==='rest' && restKindsMatch(c.restKind||null, 'house'));
  const targetingHouse = u.restTarget && restKindsMatch(u.restTarget.kind||null, 'house');
  const roadDue = u.idleMinutes >= IDLE_TO_ROAD_MINUTES;
  if(!roadDue) return;

  const onRoad = hereTile===TileType.ROAD;
  const houseDue = onRoad && u.idleMinutes >= IDLE_TO_SHELTER_MINUTES;

  if(houseDue){
    const targetHouse = findNearestHouse(u, {avoidReserved:true, reserveKind:'house'});
    if(targetHouse){
      if(u.x===targetHouse.x && u.y===targetHouse.y){
        setRestTarget(u, {x:targetHouse.x, y:targetHouse.y, kind:'house'});
      } else {
        const alreadyHeading = u.commands.some(c=>c.meta==='rest' && restKindsMatch(c.restKind||null, 'house') && c.tx===targetHouse.x && c.ty===targetHouse.y);
        if(!(alreadyHeading)){
          removeRestCommands(u);
          enqueueCommand(u, {tx:targetHouse.x, ty:targetHouse.y, type:ACTION.MOVE, meta:'rest', restKind:'house'});
        }
      }
      return;
    }
  }

  if(headingToHouse || targetingHouse) return;
  if(onRoad){
    setRestTarget(u, {x:u.x, y:u.y, kind:'road'});
    return;
  }

  const road = findNearestRoad(u, {avoidReserved:true, reserveKind:'road'});
  if(road){
    if(u.x===road.x && u.y===road.y){
      setRestTarget(u, {x:road.x, y:road.y, kind:'road'});
    } else {
      const alreadyHeading = u.commands.some(c=>c.meta==='rest' && restKindsMatch(c.restKind||null, 'road') && c.tx===road.x && c.ty===road.y);
      if(!alreadyHeading){
        removeRestCommands(u);
        enqueueCommand(u, {tx:road.x, ty:road.y, type:ACTION.MOVE, meta:'rest', restKind:'road'});
      }
    }
  }
}

function finishAction(u){
  const x=u.workX, y=u.workY; if(!inBounds(x??-1,y??-1)){ u.action=null; updateUnitState(u,'idle'); return; }
  const tile = getTile(x,y);

  if(u.action===ACTION.FIELD){ if(tile===TileType.GRASS){ tiles[y][x]=TileType.FIELD; crops[y][x]=CROP_STAGE.BARE; cropTimers[y][x]=0; readyTimers[y][x]=0; sprayed[y][x]=false; stonePicked[y][x]=false; } }
  else if(u.action===ACTION.STONE){ stonePicked[y][x]=true; }
  else if(u.action===ACTION.SNOW){ if(snow[y][x]){ snow[y][x]=false; money += SNOWPLOW_PAY; } }
  else if(u.action===ACTION.LOAD){
    if(u.loadFrom==='silo'){
      const pulled = takeFromSilo(Math.min(u.capacity - u.cargo, siloReadyGrain()));
      u.cargo += pulled; if(pulled>0) u.cargoKind='dry';
    } else {
      const donor = units.find(o=>o && o.x===x && o.y===y && o.id===u.loadTargetId);
      if(donor){
        const pulled = Math.min(donor.cargo, u.capacity - u.cargo);
        donor.cargo -= pulled; u.cargo += pulled; u.cargoKind='fresh';
      }
    }
    u.loadTargetId = null; u.loadFrom=null;
  }
  else if(u.action===ACTION.UNLOAD){
    storeInSilo(u.cargo);
    u.cargo=0; u.cargoKind=null;
  }
  else if(u.action===ACTION.SELL){
    const mult = (u.cargoKind==='dry') ? DRY_MULT : FRESH_MULT;
    money += Math.round(u.cargo * mult);
    u.cargo=0; u.cargoKind=null;
  }
  else if(tile===TileType.FIELD){
    const stage=crops[y][x];
    if(u.action===ACTION.PLOW && stage===CROP_STAGE.BARE){ crops[y][x]=CROP_STAGE.PLOWED; }
    else if(u.action===ACTION.SEED && stage===CROP_STAGE.PLOWED){ crops[y][x]=CROP_STAGE.GROWING; cropTimers[y][x]=0; sprayed[y][x]=false; }
    else if(u.action===ACTION.SPRAY && stage===CROP_STAGE.GROWING){ const gp=growthProgress(x,y); sprayed[y][x]=(gp>=SPRAY_BEST_FROM && gp<=SPRAY_BEST_TO); }
    else if(u.action===ACTION.HARVEST && stage===CROP_STAGE.READY){ const valueBase = sprayed[y][x] ? BONUS_VALUE : BASE_VALUE; const stoneBonus = stonePicked[y][x] ? STONE_BONUS_MULT : 1.0; const yieldVal = Math.round((valueBase*stoneBonus) + GRAIN_PER_TILE); const space=Math.max(0, u.capacity - u.cargo); const added=Math.min(space, yieldVal); u.cargo += added; u.cargoKind='fresh'; crops[y][x]=CROP_STAGE.BARE; sprayed[y][x]=false; stonePicked[y][x]=false; cropTimers[y][x]=0; readyTimers[y][x]=0; }
  }

  u.action=null; updateUnitState(u,'idle'); u.workX=null; u.workY=null;
}

function updateUnits(dt){
  const simDt = dt * timeScale;
  const minutesPerRealSecond = MINUTES_PER_DAY / REAL_SECONDS_PER_INGAME_DAY;
  const minuteDelta = simDt * minutesPerRealSecond;

  for (const u of units) {
    if (u.idleMinutes === undefined) u.idleMinutes = 0;
    if (u.restTarget === undefined) u.restTarget = null;
    if (u.type === UnitType.WAGON) unitHasTowPower(u);

    const active = unitIsOnShift(u);
    if (u.lastShiftState === undefined) u.lastShiftState = active;
    if (!active && u.lastShiftState) {
      handleShiftEnded(u);
    }
    u.lastShiftState = active;

    if (u.actionTimer > 0) {
      if (active) {
        u.actionTimer -= simDt;
        if (u.actionTimer <= 0) {
          finishAction(u);
          u.idleMinutes = 0;
        }
      }
      continue;
    }

    const hasCommands = u.commands.length > 0;
    const hasNonRestCommands = hasCommands ? u.commands.some(c => c.meta !== 'rest') : false;
    if (hasNonRestCommands) clearRestTarget(u);

    if (hasCommands) {
      const cmd = u.commands[0];
      const { tx, ty, type } = cmd;
      const canMove = (active || cmd.meta === 'rest') && unitHasTowPower(u);

      if (u.x === tx && u.y === ty) {
        if (type === ACTION.MOVE) {
          // Reached MOVE target â†’ pop command
          u.commands.shift();
          markUnitListDirty();

          // If queue is now empty, unit is idle
          if (!u.commands.length) {
            updateUnitState(u, 'idle');
          }

          // First command changed â†’ path is now stale
          clearUnitPath(u);
        } else {
          // At work tile: try to start the action (only during shift)
          if (active && tryStartWork(u, tx, ty, type)) {
            u.commands.shift();
            markUnitListDirty();
            clearUnitPath(u);
            u.idleMinutes = 0;
            continue; // go to next unit
          }

          // Not working yet: if off-shift, wait; otherwise drop impossible work
          if (!active) {
            updateUnitState(u, 'waiting');
          } else {
            u.commands.shift();
            markUnitListDirty();
            clearUnitPath(u);
            updateUnitState(u, 'idle');
          }
        }
      } else if (canMove) {
        u.moveCooldown -= simDt;
        if (u.moveCooldown <= 0) {
          let moved = false;
          let path = ensureUnitPath(u, tx, ty);
          if (Array.isArray(path)) {
            if (path.length) {
              let next = path[0];
              if (isOccupied(next.x, next.y, u)) {
                u.path = computePath(u, tx, ty);
                path = u.path;
                if (Array.isArray(path) && path.length) {
                  next = path[0];
                }
              }
              if (Array.isArray(path) && path.length && !isOccupied(path[0].x, path[0].y, u)) {
                if (u.type === UnitType.WAGON) {
                  const tractor = units.find(o=>o && o.id===u.hitchedTo);
                  const tractorCanPull = tractor && tractor.moveCooldown<=0 && tractor.actionTimer<=0 && (!tractor.commands || !tractor.commands.some(c=>c.meta!=='rest'));
                  const step = path[0];
                  const tractorDest = {x:u.x, y:u.y};
                  const tractorAdj = tractorCanPull && Math.abs(tractor.x-tractorDest.x)+Math.abs(tractor.y-tractorDest.y)===1;
                  if(tractorAdj && !isOccupied(step.x, step.y, u) && !isOccupied(tractorDest.x, tractorDest.y, tractor)){
                    path.shift();
                    u.x = step.x; u.y = step.y; moved = true;
                    tractor.x = tractorDest.x; tractor.y = tractorDest.y; tractor.moveCooldown = MOVE_DELAY; tractor.idleMinutes = 0;
                    updateUnitState(tractor, 'moving');
                  }
                } else {
                  const step = path.shift();
                  const prevX = u.x;
                  const prevY = u.y;
                  u.x = step.x;
                  u.y = step.y;
                  moved = true;

                  // If a wagon is hitched to this tractor and idle, drag it along.
                  if (u.type === UnitType.TRACTOR) {
                    const wagon = units.find(w => w && w.type === UnitType.WAGON && w.hitchedTo === u.id && Math.abs(w.x - prevX) + Math.abs(w.y - prevY) === 1);
                    const wagonFree = wagon && !wagon.actionTimer && wagon.moveCooldown <= 0 && !isOccupied(prevX, prevY, wagon);
                    const wagonIdleQueue = wagon && (!wagon.commands.length || wagon.commands.every(c => c.meta === 'rest'));
                    if (wagon && wagonFree && wagonIdleQueue) {
                      clearUnitPath(wagon);
                      wagon.x = prevX;
                      wagon.y = prevY;
                      wagon.moveCooldown = MOVE_DELAY;
                      wagon.idleMinutes = 0;
                      updateUnitState(wagon, 'moving');
                    }
                  }
                }
              }
            } else if (u.x !== tx || u.y !== ty) {
              u.path = computePath(u, tx, ty);
            }
          }

          if (moved) {
            u.moveCooldown = MOVE_DELAY;
            updateUnitState(u, 'moving');
            if (cmd.meta !== 'rest') u.idleMinutes = 0;
          } else {
            u.moveCooldown = MOVE_DELAY * 0.5;
            updateUnitState(u, 'waiting');
          }
        }
      } else {
        updateUnitState(u, 'waiting');
      }

      if (hasNonRestCommands) {
        u.idleMinutes = 0;
      } else {
        u.idleMinutes += minuteDelta;
        maybeSendToRest(u);
        planHauler(u);
      }
    } else {
      updateUnitState(u, 'idle');
      clearUnitPath(u);
      planHauler(u);
      u.idleMinutes += minuteDelta;
      maybeSendToRest(u);
    }
  }

  if (unitListDirty) renderUnitList();
}

/* ===== Input ===== */
let isPanning = false;
let panStart = {x:0, y:0};
let panOrigin = {x:0, y:0};
let queueDrag = null;

canvas.style.cursor = 'grab';

canvas.addEventListener('mousedown', (e)=>{
  if(e.button===1 || (e.button===0 && e.altKey)){
    isPanning = true;
    panStart = {x:e.clientX, y:e.clientY};
    panOrigin = {x:viewOffsetX, y:viewOffsetY};
    canvas.style.cursor = 'grabbing';
    e.preventDefault();
    return;
  }

  const {tx, ty} = eventToTile(e);
  if(e.button===0){
    let found=-1;
    for(let i=0;i<units.length;i++){
      if(units[i].x===tx && units[i].y===ty){ found=i; break; }
    }
    if(found!==-1){ setSelectedUnit(found); }
    selectedTile = {x:tx, y:ty};
    renderTileInfo();
  }
  else if(e.button===2){
    queueDrag = null;
    if(selectedUnit>=0 && selectedUnit<units.length){
      const u=units[selectedUnit];
      const append = e.shiftKey;
      const type = currentMode;
      if(!append){ if(u.commands.length){ u.commands.length=0; markUnitListDirty(); } clearRestTarget(u); renderUnitList(); }
      if(inBounds(tx,ty)){
        enqueueCommand(u, {tx,ty,type});
        queueDrag = { unit:u, type, visited:new Set([`${tx},${ty}`]), last:{tx, ty} };
      }
    }
  }
});

canvas.addEventListener('mousemove', (e)=>{
  if(isPanning){
    const dx = (e.clientX - panStart.x) / viewScale;
    const dy = (e.clientY - panStart.y) / viewScale;
    viewOffsetX = panOrigin.x - dx;
    viewOffsetY = panOrigin.y - dy;
    clampView();
  }

  if(queueDrag){
    if(!(e.buttons & 2)){
      endQueueDrag();
      return;
    }
    const {tx, ty} = eventToTile(e);
    if(!inBounds(tx,ty)) return;
    const last = queueDrag.last;
    if(!last){
      const key = `${tx},${ty}`;
      if(!queueDrag.visited.has(key)){
        queueDrag.visited.add(key);
        enqueueCommand(queueDrag.unit, {tx,ty,type:queueDrag.type});
      }
      queueDrag.last = {tx, ty};
      return;
    }
    if(last.tx===tx && last.ty===ty) return;
    let cx = last.tx;
    let cy = last.ty;
    const stepX = Math.sign(tx - cx);
    const stepY = Math.sign(ty - cy);
    while(cx !== tx || cy !== ty){
      if(cx !== tx) cx += stepX;
      if(cy !== ty) cy += stepY;
      if(!inBounds(cx,cy)) continue;
      const key = `${cx},${cy}`;
      if(!queueDrag.visited.has(key)){
        queueDrag.visited.add(key);
        enqueueCommand(queueDrag.unit, {tx:cx,ty:cy,type:queueDrag.type});
      }
    }
    queueDrag.last = {tx, ty};
  }
});

function endPan(){
  if(!isPanning) return;
  isPanning = false;
  canvas.style.cursor = 'grab';
}

function endQueueDrag(){
  if(!queueDrag) return;
  queueDrag = null;
  if(unitListDirty) renderUnitList();
  saveGame();
}

canvas.addEventListener('mouseup', endPan);
canvas.addEventListener('mouseleave', endPan);
window.addEventListener('mouseup', endPan);
canvas.addEventListener('mouseup', endQueueDrag);
canvas.addEventListener('mouseleave', endQueueDrag);
window.addEventListener('mouseup', endQueueDrag);

canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const point = eventToTile(e);
  const prevScale = viewScale;
  const zoomFactor = Math.exp(-e.deltaY * 0.001);
  viewScale = clamp(viewScale * zoomFactor, MIN_VIEW_SCALE, MAX_VIEW_SCALE);
  if(viewScale === prevScale) return;
  const mx = point.mx;
  const my = point.my;
  const worldX = point.wx;
  const worldY = point.wy;
  viewOffsetX = worldX - (mx / viewScale);
  viewOffsetY = worldY - (my / viewScale);
  clampView();
}, {passive:false});

canvas.oncontextmenu = (e)=> e.preventDefault();

/* ===== UI ===== */
pauseBtn.onclick = ()=>{ paused=!paused; pauseBtn.textContent = paused?'Resume':'Pause'; };
speed1Btn.onclick = ()=> timeScale = 1;
speed3Btn.onclick = ()=> timeScale = 3;
resetBtn.onclick = ()=> { localStorage.removeItem('farm_rts_save'); startNewGame(); };
sleepBtn.onclick = ()=>{
  const minuteInDay = Math.floor(gameMinutes % MINUTES_PER_DAY);
  const startOfDay = gameMinutes - minuteInDay;
  let target = startOfDay + SHIFT_START_H*60;
  if(gameMinutes >= target - 1e-6) target += MINUTES_PER_DAY;
  const delta = target - gameMinutes;
  if(delta <= 0) return;
  fastForwardMinutes(delta);
  gameMinutes = target;
  refreshHud();
  renderTileInfo();
  saveGame();
};

function addMoneySafe(v){ money += v; if(money<0) money=0; }
function spawnAtHub(type){ const hub = getHubSpawn(); const u = createUnit(type, hub.x, hub.y); units.push(u); setSelectedUnit(units.length-1); }

buyTractorBtn.onclick = ()=>{ if(money>=COST.TRACTOR){ addMoneySafe(-COST.TRACTOR); spawnAtHub(UnitType.TRACTOR); saveGame(); } };
buyHarvesterBtn.onclick = ()=>{ if(money>=COST.HARVESTER){ addMoneySafe(-COST.HARVESTER); spawnAtHub(UnitType.HARVESTER); saveGame(); } };
buySprayerBtn.onclick = ()=>{ if(money>=COST.SPRAYER){ addMoneySafe(-COST.SPRAYER); spawnAtHub(UnitType.SPRAYER); saveGame(); } };
buyWagonBtn.onclick = ()=>{ if(money>=COST.WAGON){ addMoneySafe(-COST.WAGON); spawnAtHub(UnitType.WAGON); saveGame(); } };
buySemiBtn.onclick = ()=>{ if(money>=COST.SEMI){ addMoneySafe(-COST.SEMI); spawnAtHub(UnitType.SEMI); saveGame(); } };

modeBar.addEventListener('click', (e)=>{ const b = e.target.closest('button[data-mode]'); if(!b) return; for(const btn of modeBar.querySelectorAll('button')) btn.classList.remove('active'); b.classList.add('active'); currentMode = b.dataset.mode; });

window.addEventListener('keydown', (e)=>{
  if(!e.shiftKey) return;
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
  if(tag==='input' || tag==='textarea' || tag==='select' || e.target.isContentEditable) return;
  const m = /^Digit([1-9])$/.exec(e.code);
  if(!m) return;
  const idx = Number(m[1]) - 1;
  const btn = modeBar.querySelectorAll('button[data-mode]')[idx];
  if(btn){ btn.click(); e.preventDefault(); }
});

/* ===== Sidebar: Unit list ===== */
function createUnitCard(){
  const card = document.createElement('div');
  card.className = 'unitCard';
  const header = document.createElement('div');
  header.className = 'unitHeader';
  const title = document.createElement('div');
  title.className = 'unitTitle';
  const idEl = document.createElement('strong');
  idEl.className = 'unitNumber';
  title.appendChild(idEl);
  const iconEl = document.createElement('span');
  iconEl.className = 'unitIcon';
  iconEl.style.marginLeft = '6px';
  title.appendChild(iconEl);
  const typeEl = document.createElement('span');
  typeEl.className = 'unitType';
  typeEl.style.marginLeft = '4px';
  title.appendChild(typeEl);
  const ownerTag = document.createElement('span');
  ownerTag.className = 'tag ownerTag';
  ownerTag.textContent = 'Owner';
  ownerTag.style.marginLeft = '6px';
  ownerTag.style.display = 'none';
  title.appendChild(ownerTag);
  header.appendChild(title);
  const stateTag = document.createElement('span');
  stateTag.className = 'tag stateTag';
  header.appendChild(stateTag);
  card.appendChild(header);

  const posDiv = document.createElement('div');
  posDiv.className = 'unitPos';
  posDiv.style.marginTop = '4px';
  posDiv.style.fontSize = '.86rem';
  posDiv.style.color = '#bbb';
  card.appendChild(posDiv);

  const cargoDiv = document.createElement('div');
  cargoDiv.className = 'unitCargo';
  cargoDiv.style.fontSize = '.86rem';
  cargoDiv.style.color = '#8fdd8f';
  card.appendChild(cargoDiv);

  const actions = document.createElement('div');
  actions.className = 'unitActions';
  actions.style.display = 'flex';
  actions.style.gap = '6px';
  actions.style.marginTop = '6px';
  const selectBtn = document.createElement('button');
  selectBtn.className = 'tiny secondary';
  selectBtn.setAttribute('data-act','select');
  selectBtn.textContent = 'Select';
  actions.appendChild(selectBtn);
  const clearBtn = document.createElement('button');
  clearBtn.className = 'tiny secondary';
  clearBtn.setAttribute('data-act','clear');
  clearBtn.textContent = 'Clear queue';
  actions.appendChild(clearBtn);
  card.appendChild(actions);

  const queueLabel = document.createElement('div');
  queueLabel.className = 'queueLabel';
  queueLabel.style.marginTop = '6px';
  queueLabel.style.fontSize = '.86rem';
  queueLabel.textContent = 'Queue:';
  card.appendChild(queueLabel);

  const queueList = document.createElement('ol');
  queueList.className = 'queueList';
  card.appendChild(queueList);

  card._refs = { idEl, iconEl, typeEl, ownerTag, stateTag, posDiv, cargoDiv, queueList };
  return card;
}

function updateUnitCard(card, u, idx){
  card.dataset.unitId = String(u.id);
  card.classList.toggle('selected', idx===selectedUnit);
  const refs = card._refs;
  refs.idEl.textContent = `#${u.id}`;
  refs.iconEl.textContent = iconFor(u.type);
  refs.typeEl.textContent = u.type;
  refs.ownerTag.style.display = u.isOwner ? '' : 'none';
  refs.stateTag.textContent = u.state;
  refs.posDiv.textContent = `Pos: (${u.x},${u.y})`;
  if(u.capacity>0){
    const pct = u.capacity? Math.round((u.cargo/u.capacity)*100):0;
    const kind = u.cargoKind ? (u.cargoKind==='dry'?'dry grain':'fresh grain') : 'empty';
    refs.cargoDiv.textContent = `Cargo: ${u.cargo}/${u.capacity} (${pct}% ${kind})`;
    refs.cargoDiv.style.display = '';
  } else {
    refs.cargoDiv.style.display = 'none';
  }
  const queueList = refs.queueList;
  while(queueList.firstChild) queueList.removeChild(queueList.firstChild);
  if(u.commands.length){
    for(const c of u.commands){
      const li = document.createElement('li');
      li.textContent = labelForCmd(c);
      queueList.appendChild(li);
    }
  } else {
    const li = document.createElement('li');
    const em = document.createElement('em');
    em.textContent = 'empty';
    li.appendChild(em);
    queueList.appendChild(li);
  }
}

function renderUnitList(){
  const prevScroll = unitCardsEl.scrollTop;
  const existing = new Map(Array.from(unitCardsEl.querySelectorAll('.unitCard')).map(el=>[Number(el.dataset.unitId), el]));
  units.forEach((u, idx)=>{
    let card = existing.get(u.id);
    if(card){
      existing.delete(u.id);
    } else {
      card = createUnitCard();
      unitCardsEl.insertBefore(card, unitCardsEl.children[idx] || null);
    }
    updateUnitCard(card, u, idx);
    const desiredNode = unitCardsEl.children[idx];
    if(desiredNode !== card){ unitCardsEl.insertBefore(card, desiredNode || null); }
  });
  existing.forEach(card=>card.remove());
  unitCardsEl.scrollTop = prevScroll;
  unitListDirty = false;
}

function setSelectedUnit(idx){
  if(idx<0 || idx>=units.length) return false;
  if(selectedUnit===idx) return false;
  selectedUnit = idx;
  renderUnitList();
  return true;
}

unitListEl.addEventListener('click', (e)=>{
  const card = e.target.closest('.unitCard');
  if(!card || !unitCardsEl.contains(card)) return;
  const unitId = Number(card.dataset.unitId);
  const idx = units.findIndex(u=>u.id===unitId);
  if(idx===-1) return;
  const btn = e.target.closest('button[data-act]');
  if(btn){
    const act = btn.dataset.act;
    if(act==='select'){
      setSelectedUnit(idx);
      renderTileInfo();
      saveGame();
    } else if(act==='clear'){
      const unit = units[idx];
      if(unit){
        if(unit.commands.length){ unit.commands.length = 0; markUnitListDirty(); }
        clearRestTarget(unit);
        renderUnitList();
        renderTileInfo();
        saveGame();
      }
    }
    return;
  }
  setSelectedUnit(idx);
  renderTileInfo();
  saveGame();
});
function iconFor(type){ if(type==='Tractor') return 'ðŸšœ'; if(type==='Harvester') return 'ðŸ§º'; if(type==='Sprayer') return 'ðŸ§´'; if(type==='Tractor Wagon') return 'ðŸ›»'; if(type==='Semi-truck') return 'ðŸš›'; return 'ðŸ”§'; }
function labelForCmd(c){
  if(c.meta==='rest'){
    const kind = c.restKind || 'road';
    const dest = restKindsMatch(kind, 'house') ? 'House' : 'Road';
    return `Rest to ${dest} â†’ (${c.tx},${c.ty})`;
  }
  const nameMap = {auto:'Auto', move:'Move', field:'Field', plow:'Plow', seed:'Seed', spray:'Spray', harvest:'Harvest', stone:'Stone', snow:'Snow', load:'Load', unload:'Unload', sell:'Sell'};
  return `${nameMap[c.type]||c.type} â†’ (${c.tx},${c.ty})`;
}

/* ===== Tile Info ===== */
function tileName(t){ if(t===TileType.GRASS) return 'Grass'; if(t===TileType.FIELD) return 'Field'; if(t===TileType.ROAD) return 'Road'; if(t===TileType.SILO) return 'Silo'; if(t===TileType.ELEVATOR) return 'Grain Elevator'; return 'Farm Hub'; }
function stageName(s){ return s===CROP_STAGE.BARE?'Bare' : s===CROP_STAGE.PLOWED?'Plowed' : s===CROP_STAGE.GROWING?'Growing' : s===CROP_STAGE.READY?'Ready' : 'â€”'; }
function adviceFor(x,y){
  if(!inBounds(x,y)) return 'Out of bounds';
  const t = getTile(x,y); if(t===TileType.HOUSE) return 'Farm Hub: purchases spawn here.';
  const s = seasonFromMinutes(gameMinutes);
  if(t===TileType.GRASS){
    if(s.seasonIndex===3 && getSnow(x,y)) return 'Winter: Clear snow here with a Tractor or convert to a field later.';
    return 'Use Tractor + FIELD to create a field here.';
  }
  if(t!==TileType.FIELD) return (t===TileType.ROAD && s.seasonIndex===3 && getSnow(x,y)) ? 'Winter: Snowplow to keep roads clear (Tractor).' : 'Non-farm tile.';
  const st = getStage(x,y);
  if(st===CROP_STAGE.BARE){ if(!getStone(x,y)) return 'Optional: Stone pick (bonus), then Plow.'; return 'Plow next (Tractor).'; }
  if(st===CROP_STAGE.PLOWED){ if(s.seasonIndex===3) return 'Too cold: seeding disabled in Winter.'; return 'Seed next (Tractor).'; }
  if(st===CROP_STAGE.GROWING){ const gp=growthProgress(x,y); if(s.seasonIndex===3) return 'Dormant in Winter. Wait for Spring.'; if(gp < SPRAY_BEST_FROM) return 'Growingâ€¦ Spray soon for bonus.'; if(gp <= SPRAY_BEST_TO) return 'Spray now (Sprayer) for bonus yield.'; return 'Growingâ€¦ (late for bonus). Wait for Ready â†’ Harvest.'; }
  if(st===CROP_STAGE.READY){ const rp=readyProgress(x,y); const winterNote = s.seasonIndex===3 ? ' (decays faster in Winter)' : ''; return (rp<0.5) ? `Ready â€” Harvest soon${winterNote}.` : `Urgent: Harvest before decay!${winterNote}`; }
  return 'â€”';
}
function renderTileInfo(){
  const x = selectedTile.x, y = selectedTile.y; const t = inBounds(x,y)? getTile(x,y) : undefined; const st = (t===TileType.FIELD) ? getStage(x,y) : CROP_STAGE.NONE; const rows = [];
  rows.push(`<span>Position</span><span>(${x},${y})</span>`);
  rows.push(`<span>Type</span><span>${tileName(t)}</span>`);
  if(t===TileType.FIELD){ rows.push(`<span>Stage</span><span>${stageName(st)}</span>`); if(st===CROP_STAGE.GROWING){ rows.push(`<span>Growth</span><span>${Math.round(growthProgress(x,y)*100)}%</span>`); rows.push(`<span>Sprayed</span><span>${getSprayed(x,y)?'Yes (effective)':'No/ineffective'}</span>`); } else if(st===CROP_STAGE.READY){ rows.push(`<span>Ready Window</span><span>${Math.round((1-readyProgress(x,y))*100)}% left</span>`); } rows.push(`<span>Stone picked</span><span>${getStone(x,y)?'Yes (+10%)':'No'}</span>`); rows.push(`<span>Snow</span><span>${getSnow(x,y)?'Yes (clear with Snow)':'No'}</span>`); }
  else if(t===TileType.ROAD){ rows.push(`<span>Snow</span><span>${getSnow(x,y)?'Yes (Snowplow for $)':'No'}</span>`); }
  else if(t===TileType.GRASS){ rows.push(`<span>Snow</span><span>${getSnow(x,y)?'Yes (clear with Snow)':'No'}</span>`); }
  else if(t===TileType.SILO){ rows.push(`<span>Stored</span><span>${siloStorage.reduce((a,c)=>a+c.amount,0)} grain</span>`); rows.push(`<span>Dry & ready</span><span>${siloReadyGrain()} grain</span>`); rows.push('<span>Tip</span><span>Wagons & semis drop here to dry harvest.</span>'); }
  else if(t===TileType.ELEVATOR){ rows.push('<span>Sellpoint</span><span>Best payout for dried grain.</span>'); rows.push(`<span>Dry bonus</span><span>${Math.round((DRY_MULT-1)*100)}% over fresh</span>`); rows.push(`<span>Fresh penalty</span><span>${Math.round((1-FRESH_MULT)*100)}% hit</span>`); }
  rows.push(`<span>Tip</span><span>${adviceFor(x,y)}</span>`);
  tileKV.innerHTML = rows.map(r=>`<span>${r.split('</span><span>')[0]}</span><span>${r.split('</span><span>')[1]??''}</span>`).join('');
}

/* ===== Color & lighting helpers ===== */
function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function hexToRgb(hex){ hex = hex.replace('#',''); if(hex.length===3){ hex = hex.split('').map(c=>c+c).join(''); } const num = parseInt(hex,16); return {r:(num>>16)&255, g:(num>>8)&255, b:num&255}; }
function rgbToHex(r,g,b){ const n=(r<<16)|(g<<8)|b; return '#'+n.toString(16).padStart(6,'0'); }
function lerp(a,b,t){ return a + (b-a)*t; }
function lerpColor(hexA,hexB,t){ const A=hexToRgb(hexA), B=hexToRgb(hexB); return rgbToHex(Math.round(lerp(A.r,B.r,t)), Math.round(lerp(A.g,B.g,t)), Math.round(lerp(A.b,B.b,t))); }
function brighten(hex, factor){ const c=hexToRgb(hex); const r=clamp01(factor); const rr=Math.min(255, Math.round(c.r*r)); const gg=Math.min(255, Math.round(c.g*r)); const bb=Math.min(255, Math.round(c.b*r)); return rgbToHex(rr,gg,bb); }

// Day/night factor: 0.6 at midnight â†’ 1.2 at noon
function dayLightFactor(){
  const minuteInDay = Math.floor(gameMinutes%MINUTES_PER_DAY);
  const h = minuteInDay/60;           // 0..24
  // shift so 12:00 is peak; cosine curve from 0 at midnight to 1 at noon
  const t = Math.cos((Math.PI * (h-12))/12); // -1..1
  const k = clamp01((t+1)/2);               // 0..1 with peak at noon
  return 0.6 + 0.6*k;                       // 0.6..1.2
}

function sunPosition(){
  const minuteInDay = Math.floor(gameMinutes%MINUTES_PER_DAY);
  const h = minuteInDay/60; // 0..24
  const x = (h/24)*WORLD_W;
  const height = Math.sin(Math.PI * clamp01((h-6)/12)); // 0 at 6 & 18, 1 at 12
  const y = (1-height)*WORLD_H*0.7 + WORLD_H*0.05; // arc over top third
  return {x, y, height: clamp01(height)};
}

function clampView(){
  const viewW = canvas.width / viewScale;
  const viewH = canvas.height / viewScale;
  const maxX = Math.max(0, WORLD_W - viewW);
  const maxY = Math.max(0, WORLD_H - viewH);
  const minX = maxX===0 ? -(viewW - WORLD_W)/2 : 0;
  const minY = maxY===0 ? -(viewH - WORLD_H)/2 : 0;
  viewOffsetX = clamp(viewOffsetX, minX, maxX);
  viewOffsetY = clamp(viewOffsetY, minY, maxY);
}

function screenToWorld(mx, my){
  return {
    wx: viewOffsetX + mx / viewScale,
    wy: viewOffsetY + my / viewScale
  };
}

function eventToTile(e){
  const rect = canvas.getBoundingClientRect();
  const cssX = e.clientX - rect.left;
  const cssY = e.clientY - rect.top;
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = cssX * scaleX;
  const my = cssY * scaleY;
  const {wx, wy} = screenToWorld(mx, my);
  return {
    tx: Math.floor(wx / TILE_SIZE),
    ty: Math.floor(wy / TILE_SIZE),
    wx,
    wy,
    mx,
    my
  };
}

clampView();

function resizeCanvasViewport(){
  if(!boardWrap || !gameContainer) return;
  const rect = boardWrap.getBoundingClientRect();
  const margin = 16;
  const padding = 20;
  const availableWidth = Math.max(padding + 200, window.innerWidth - rect.left - margin);
  const availableHeight = Math.max(padding + 200, window.innerHeight - rect.top - margin);
  const innerWidth = availableWidth - padding;
  const innerHeight = availableHeight - padding;
  const aspect = canvas.width / canvas.height;
  let targetInnerWidth = innerWidth;
  let targetInnerHeight = targetInnerWidth / aspect;
  if(targetInnerHeight > innerHeight){
    targetInnerHeight = innerHeight;
    targetInnerWidth = targetInnerHeight * aspect;
  }
  targetInnerWidth = Math.min(targetInnerWidth, canvas.width);
  targetInnerHeight = Math.min(targetInnerHeight, canvas.height);
  gameContainer.style.width = `${targetInnerWidth + padding}px`;
  gameContainer.style.height = `${targetInnerHeight + padding}px`;
  canvas.style.width = `${targetInnerWidth}px`;
  canvas.style.height = `${targetInnerHeight}px`;
}

/* ===== Rendering ===== */
function drawTiles(){
  const hubSet = new Set(getHubTiles().map(h=>`${h.x},${h.y}`));
  const light = dayLightFactor();
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      const t=tiles[y][x]; let fill='#265626';
      if(t===TileType.ROAD) fill='#6e4038';
      else if(t===TileType.SILO) fill='#7f8799';
      else if(t===TileType.ELEVATOR) fill='#6c6cd8';
      else if(t===TileType.HOUSE) fill='#0f1220';
      else if(t===TileType.FIELD){
        const st=crops[y][x];
        if(st===CROP_STAGE.BARE) fill='#6f522d';
        else if(st===CROP_STAGE.PLOWED) fill='#8c6336';
        else if(st===CROP_STAGE.GROWING){
          const gp=growthProgress(x,y);
          // richer gradient: early deep green â†’ lush lime; sprayed shifts hue a bit
          const from = sprayed[y][x] ? '#1d7a34' : '#175e2a';
          const mid  = sprayed[y][x] ? '#28a54b' : '#2c8a3e';
          const to   = sprayed[y][x] ? '#7cf58a' : '#68d86f';
          const t1 = clamp01(gp*1.2); // a bit front-loaded
          const col1 = lerpColor(from, mid, t1);
          const col2 = lerpColor(mid,  to,  clamp01((gp-0.5)*2));
          fill = gp<0.5 ? col1 : col2;
        }
        else if(st===CROP_STAGE.READY) fill='#c9b24a';
      }
      // apply daylight brightness
      fill = brighten(fill, light);
      ctx.fillStyle=fill; ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.strokeRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);

      // Snow overlay
      if(getSnow(x,y)){ ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.fillRect(x*TILE_SIZE+4,y*TILE_SIZE+4,TILE_SIZE-8,TILE_SIZE-8); }

      // Visual hints: spray window & urgency rings
      if(tiles[y][x]===TileType.FIELD){ const st=crops[y][x]; if(st===CROP_STAGE.GROWING){ const gp=growthProgress(x,y); if(gp>=SPRAY_BEST_FROM && gp<=SPRAY_BEST_TO){ ctx.strokeStyle='rgba(0,255,120,.85)'; ctx.lineWidth=2 / viewScale; ctx.strokeRect(x*TILE_SIZE+6,y*TILE_SIZE+6,TILE_SIZE-12,TILE_SIZE-12); } } else if(st===CROP_STAGE.READY){ const rp=readyProgress(x,y); if(rp>0.6){ ctx.strokeStyle='rgba(255,90,0,.85)'; ctx.lineWidth=2 / viewScale; ctx.strokeRect(x*TILE_SIZE+4,y*TILE_SIZE+4,TILE_SIZE-8,TILE_SIZE-8); } } }

      if(hubSet.has(`${x},${y}`)){ ctx.lineWidth = 3 / viewScale; ctx.strokeStyle='rgba(0,255,208,0.9)'; ctx.strokeRect(x*TILE_SIZE+2,y*TILE_SIZE+2,TILE_SIZE-4,TILE_SIZE-4); ctx.fillStyle='rgba(0,255,208,0.08)'; ctx.fillRect(x*TILE_SIZE+2,y*TILE_SIZE+2,TILE_SIZE-4,TILE_SIZE-4); ctx.fillStyle = '#00e6be'; ctx.font = 'bold 18px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('H', x*TILE_SIZE+TILE_SIZE/2, y*TILE_SIZE+TILE_SIZE/2); }

      if(x===selectedTile.x && y===selectedTile.y){ ctx.lineWidth=2 / viewScale; ctx.strokeStyle='#00ffff'; ctx.strokeRect(x*TILE_SIZE+2,y*TILE_SIZE+2,TILE_SIZE-4,TILE_SIZE-4); }
    }
  }
}

function drawQueueForSelected(){
  const u = units[selectedUnit];
  if(!u || !u.commands.length) return;
  const scaleInv = 1 / viewScale;
  ctx.lineWidth = 2 * scaleInv;
  ctx.strokeStyle = 'rgba(255,255,0,.9)';
  ctx.setLineDash([4 * scaleInv, 4 * scaleInv]);
  let prevX = u.x*TILE_SIZE + TILE_SIZE/2;
  let prevY = u.y*TILE_SIZE + TILE_SIZE/2;
  for(const c of u.commands){
    const cx = c.tx*TILE_SIZE + TILE_SIZE/2;
    const cy = c.ty*TILE_SIZE + TILE_SIZE/2;
    ctx.beginPath();
    ctx.moveTo(prevX,prevY);
    ctx.lineTo(cx,cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(cx,cy,6,0,Math.PI*2);
    ctx.stroke();
    prevX=cx;
    prevY=cy;
  }
  ctx.setLineDash([]);
}

function drawUnits(){
  for(let i=0;i<units.length;i++){
    const u=units[i]; const px=u.x*TILE_SIZE, py=u.y*TILE_SIZE; const cx=px+TILE_SIZE/2, cy=py+TILE_SIZE/2;
    if(u.type===UnitType.TRACTOR){
      // Tractor: two large wheels + chassis + cab
      const bodyColor = u.isOwner ? (u.state==='working' ? '#ff8b7d' : '#e0463f') : (u.state==='working' ? '#3bc0ff' : '#1f8fe0');
      ctx.fillStyle = bodyColor;
      // wheels
      ctx.beginPath(); ctx.arc(px+8, py+TILE_SIZE-7, 5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+TILE_SIZE-8, py+TILE_SIZE-7, 6, 0, Math.PI*2); ctx.fill();
      // body
      ctx.fillRect(px+6, py+8, TILE_SIZE-12, 10);
      // cab
      ctx.fillStyle='#eaeef7'; ctx.fillRect(px+10, py+4, TILE_SIZE-20, 8);
    } else if(u.type===UnitType.HARVESTER){
      // Harvester: wide header + body
      ctx.fillStyle = u.state==='working' ? '#b9e15d' : '#9ad24a';
      // header
      ctx.fillRect(px+2, py+TILE_SIZE-10, TILE_SIZE-4, 4);
      // body
      ctx.fillRect(px+5, py+6, TILE_SIZE-10, TILE_SIZE-14);
      // cab window
      ctx.fillStyle='#f0f6ff'; ctx.fillRect(px+9, py+8, TILE_SIZE-18, 8);
    } else if(u.type===UnitType.SPRAYER){
      // Sprayer: tank + booms
      ctx.fillStyle = u.state==='working' ? '#7cc7ff' : '#5aa9e6';
      // tank (circle)
      ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
      // booms
      ctx.fillRect(px+4, cy-1, TILE_SIZE-8, 2);
      ctx.fillRect(cx-1, py+4, 2, TILE_SIZE-8);
    } else if(u.type===UnitType.WAGON){
      // Tractor wagon: box body with small wheels
      ctx.fillStyle = u.state==='working' ? '#f3c86c' : '#e2af43';
      ctx.strokeStyle = '#2b1d04';
      ctx.lineWidth = 2 / viewScale;
      ctx.fillRect(px+4, py+6, TILE_SIZE-8, TILE_SIZE-12);
      ctx.strokeRect(px+4, py+6, TILE_SIZE-8, TILE_SIZE-12);
      ctx.fillStyle = '#2d2d2d';
      ctx.beginPath(); ctx.arc(px+8, py+TILE_SIZE-6, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+TILE_SIZE-8, py+TILE_SIZE-6, 4, 0, Math.PI*2); ctx.fill();
      if(u.hitchedTo){
        const tractor = units.find(o=>o && o.id===u.hitchedTo);
        if(tractor){
          ctx.strokeStyle = '#ffd24a';
          ctx.lineWidth = 2 / viewScale;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(tractor.x*TILE_SIZE + TILE_SIZE/2, tractor.y*TILE_SIZE + TILE_SIZE/2);
          ctx.stroke();
        }
      }
    } else if(u.type===UnitType.SEMI){
      // Semi-truck: extended trailer + cab (approx two tiles long)
      const trailerX = px;
      const trailerY = py + 6;
      const trailerW = TILE_SIZE * 2 - 8;
      const trailerH = TILE_SIZE - 12;
      ctx.fillStyle = u.state==='working' ? '#d9e4f5' : '#c4cedd';
      ctx.strokeStyle = '#1c2c48';
      ctx.lineWidth = 2 / viewScale;
      ctx.fillRect(trailerX, trailerY, trailerW, trailerH);
      ctx.strokeRect(trailerX, trailerY, trailerW, trailerH);

      // Cab at the front-right
      ctx.fillStyle = '#eef4ff';
      ctx.fillRect(px+TILE_SIZE-4, py+4, TILE_SIZE-6, TILE_SIZE-10);
      ctx.fillStyle = '#2f6cd8';
      ctx.fillRect(px+TILE_SIZE+4, py+8, TILE_SIZE-14, TILE_SIZE-18);
      ctx.strokeRect(px+TILE_SIZE+4, py+8, TILE_SIZE-14, TILE_SIZE-18);

      // Wheels
      ctx.fillStyle = '#1f1f1f';
      const wheelY = py + TILE_SIZE - 6;
      ctx.beginPath(); ctx.arc(px+10, wheelY, 4.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+TILE_SIZE+4, wheelY, 4.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+TILE_SIZE*2-12, wheelY, 4.5, 0, Math.PI*2); ctx.fill();
    }
    if(i===selectedUnit){
      ctx.lineWidth = 2 / viewScale;
      ctx.strokeStyle = '#ffd700';
      ctx.strokeRect(px+2,py+2,TILE_SIZE-4,TILE_SIZE-4);
    }
  }
}

function drawSunOverlay(){
  const {x,y,height} = sunPosition();
  const grad = ctx.createRadialGradient(x,y,10, x,y, 140);
  // Day glow is warm; at night we skip the glow and rely on dimming via tile brightness
  const alpha = 0.12 * height;
  grad.addColorStop(0, `rgba(255,240,180,${alpha})`);
  grad.addColorStop(1, 'rgba(255,240,180,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,WORLD_W,WORLD_H);
}

function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.scale(viewScale, viewScale);
  ctx.translate(-viewOffsetX, -viewOffsetY);
  drawTiles();
  const s = seasonFromMinutes(gameMinutes);
  ctx.fillStyle = ['rgba(80,200,120,0.05)','rgba(255,200,80,0.05)','rgba(255,140,0,0.05)','rgba(180,220,255,0.08)'][s.seasonIndex];
  ctx.fillRect(0,0,WORLD_W,WORLD_H);
  drawSunOverlay();
  drawQueueForSelected();
  drawUnits();
  ctx.restore();
  moneySpan.textContent = Math.floor(money).toString();
}

/* ===== Persistence ===== */
function saveGame(){ const save = { money, gameMinutes, tiles, crops, cropTimers, readyTimers, sprayed, units, nextUnitId, selectedUnit, snow, stonePicked, siloStorage, preset: presetSel.value, planScope: planScopeSel ? planScopeSel.value : 'all' }; try{ localStorage.setItem('farm_rts_save', JSON.stringify(save)); }catch(e){} }
function ensureOwnerTractor(){
  let owner = units.find(u=>u.isOwner && u.type===UnitType.TRACTOR);
  let changed = false;
  if(!owner){
    const firstTractor = units.find(u=>u.type===UnitType.TRACTOR);
    if(firstTractor){
      if(!firstTractor.isOwner){ firstTractor.isOwner = true; changed = true; }
      if(!firstTractor.alwaysActive){ firstTractor.alwaysActive = true; }
      owner = firstTractor;
    }
  }
  if(!owner){
    const hub = getHubSpawn();
    const replacement = createUnit(UnitType.TRACTOR, hub.x, hub.y, {isOwner:true, alwaysActive:true});
    units.unshift(replacement);
    changed = true;
  }
  if(changed){ markUnitListDirty(); renderUnitList(); }
}
  function loadGame(){ const raw = localStorage.getItem('farm_rts_save'); if(!raw) return false; try{ const s = JSON.parse(raw); money = s.money ?? money; gameMinutes = s.gameMinutes ?? gameMinutes; tiles=s.tiles||tiles; crops=s.crops||crops; cropTimers=s.cropTimers||cropTimers; readyTimers=s.readyTimers||readyTimers; sprayed=s.sprayed||sprayed; snow=s.snow||snow; stonePicked=s.stonePicked||stonePicked; siloStorage = s.siloStorage || []; rebuildSiloListsFromTiles(); units.length=0; (s.units||[]).forEach(u=>{ u.commands = u.commands || []; u.isOwner = !!u.isOwner; u.alwaysActive = !!u.alwaysActive; u.idleMinutes = u.idleMinutes ?? 0; u.restTarget = null; u.lastShiftState = u.alwaysActive ? true : withinShift(); u.cargo = u.cargo ?? 0; u.cargoKind = u.cargoKind ?? null; u.capacity = u.capacity ?? capacityFor(u.type); units.push(u); }); nextUnitId = s.nextUnitId ?? 1; selectedUnit = Math.min(s.selectedUnit ?? 0, Math.max(0, units.length-1)); if(s.preset) presetSel.value=s.preset; if(s.planScope && planScopeSel) planScopeSel.value = s.planScope; ensureOwnerTractor(); ensureGridDims(); return true; }catch(e){ return false; } }

/* ===== Tests ===== */
function assert(cond, msg){ if(!cond) throw new Error(msg); }
function printResult(ok, msg){ const p=document.createElement('div'); p.className= ok? 'test-pass':'test-fail'; p.textContent=(ok?'âœ” ':'âœ– ')+msg; testResults.appendChild(p); }
function clearResults(){ testResults.textContent=''; }
function capacityNumbers(){
  const tractorCap = Math.floor(GROWTH_TIME / (PLOW_TIME + SEED_TIME));
  const sprayWindow = (SPRAY_BEST_TO - SPRAY_BEST_FROM) * GROWTH_TIME;
  const sprayerCap = Math.floor(sprayWindow / SPRAY_TIME);
  const harvesterCap = Math.floor(READY_WINDOW / HARVEST_TIME);
  const perDayPlow = Math.floor(SHIFT_SECONDS_PER_INGAME_DAY / PLOW_TIME);
  const perDaySeed = Math.floor(SHIFT_SECONDS_PER_INGAME_DAY / SEED_TIME);
  const perDaySpray = Math.floor(SHIFT_SECONDS_PER_INGAME_DAY / SPRAY_TIME);
  const perDayHarvest = Math.floor(SHIFT_SECONDS_PER_INGAME_DAY / HARVEST_TIME);
  return {tractorCap, sprayerCap, harvesterCap, perDayPlow, perDaySeed, perDaySpray, perDayHarvest};
}
function runTests(){
  clearResults();
  try{
    // Season math
    const s0 = seasonFromMinutes(8*60); assert(s0.seasonName==='Spring' && s0.dayInSeason===1, 'Season start should be Spring, Day 1');
    const sEndSpring = seasonFromMinutes((DAYS_PER_SEASON-1)*MINUTES_PER_DAY); assert(sEndSpring.seasonName==='Spring' && sEndSpring.dayInSeason===DAYS_PER_SEASON, 'End of Spring maps correctly');
    const sSummer = seasonFromMinutes(DAYS_PER_SEASON*MINUTES_PER_DAY); assert(sSummer.seasonName==='Summer' && sSummer.dayInSeason===1, 'Summer begins after 4 days');
    assert(seasonGrowthMult(3)===0, 'Winter growth should be 0');
    assert(seasonDecayMult(3)>1, 'Winter decay is faster');
    const hub = getHubSpawn(); assert(baseRows[hub.y][hub.x]==='H', 'Hub spawn should be on an H tile');

    // Capacity targets: 50 per task per shift
    const caps = capacityNumbers();
    assert(caps.perDayPlow   >= 50, `Per-day plow capacity â‰¥50 (got ${caps.perDayPlow})`);
    assert(caps.perDaySeed   >= 50, `Per-day seed capacity â‰¥50 (got ${caps.perDaySeed})`);
    assert(caps.perDaySpray  >= 50, `Per-day spray capacity â‰¥50 (got ${caps.perDaySpray})`);
    assert(caps.perDayHarvest>= 50, `Per-day harvest capacity â‰¥50 (got ${caps.perDayHarvest})`);
    printResult(true,`Per-shift: P=${caps.perDayPlow}, Sd=${caps.perDaySeed}, Sp=${caps.perDaySpray}, Hv=${caps.perDayHarvest}`);

    // Bounds-safety tests
    assert(adviceFor(-1,0)==='Out of bounds', 'Advice returns OOB safely');
    const dummy = createUnit(UnitType.TRACTOR,0,0); assert(tryStartWork(dummy,-1,0,'plow')===false, 'tryStartWork ignores OOB');

    // Grid normalization test (simulate broken save)
    const oldTiles = tiles; tiles = []; ensureGridDims(); assert(tiles[0][0]!==undefined, 'ensureGridDims rebuilds grid'); tiles = oldTiles;

    printResult(true,'Core season, shift, capacity & safety tests passed');
  }catch(e){ printResult(false, e.message); }
}

/* ===== Assisted Planner (QoL) ===== */
let ASSISTED = false;
function applyPreset(){ ASSISTED = (presetSel.value==='assist'); MOVE_DELAY = ASSISTED ? 0.22 : 0.25; planBtn.style.display = ASSISTED ? 'inline-block' : 'none'; if(planScopeWrap) planScopeWrap.style.display = ASSISTED ? 'flex' : 'none'; if(planScopeSel) planScopeSel.disabled = !ASSISTED; }
function nearestFirst(from, targets){
  return targets.slice().sort((p,q)=>{
    const distP = Math.abs(from.x-p.x) + Math.abs(from.y-p.y);
    const distQ = Math.abs(from.x-q.x) + Math.abs(from.y-q.y);
    return distP - distQ;
  });
}
function listTilesWhere(pred){ const out=[]; for(let y=0;y<GRID_H;y++){ for(let x=0;x<GRID_W;x++){ if(pred(x,y)) out.push({x,y}); } } return out; }

function assignUniqueTasks(units, tasks, perUnitLimit, actionType){
  if(!units.length || !tasks.length || perUnitLimit<=0) return;
  const remaining = tasks.slice();
  const assignedCount = new Map(units.map(u=>[u.id, 0]));
  const priorityOf = (task)=> task && typeof task.priority==='number' ? task.priority : 0;

  // Round-robin through units, always giving the next task to the unit with
  // the smallest workload so we spread the queue evenly.
  while(remaining.length){
    const eligible = units.filter(u=> (assignedCount.get(u.id) ?? 0) < perUnitLimit);
    if(!eligible.length) break;

    const bestPriority = Math.min(...remaining.map(priorityOf));
    const samePriority = remaining.filter(t=>priorityOf(t)===bestPriority);
    if(!samePriority.length) break;

    eligible.sort((a,b)=>{
      const diff = (assignedCount.get(a.id) ?? 0) - (assignedCount.get(b.id) ?? 0);
      if(diff!==0) return diff;
      const nearestA = nearestFirst(a, samePriority)[0];
      const nearestB = nearestFirst(b, samePriority)[0];
      const distA = nearestA ? Math.abs(a.x-nearestA.x)+Math.abs(a.y-nearestA.y) : Infinity;
      const distB = nearestB ? Math.abs(b.x-nearestB.x)+Math.abs(b.y-nearestB.y) : Infinity;
      return distA - distB;
    });

    const unit = eligible[0];
    const ordered = nearestFirst(unit, samePriority);
    const target = ordered[0];
    if(!target) break;
    const targetPriority = priorityOf(target);
    const idx = remaining.findIndex(p=>p.x===target.x && p.y===target.y && priorityOf(p)===targetPriority);
    if(idx===-1) continue;

    remaining.splice(idx,1);
    enqueueCommand(unit, {tx:target.x, ty:target.y, type:actionType});
    assignedCount.set(unit.id, (assignedCount.get(unit.id) ?? 0) + 1);
  }
}

function planCycle(){ if(!ASSISTED) return;
  const scope = planScopeSel ? planScopeSel.value : 'all';
  const planPlow = scope==='all' || scope==='plow';
  const planStone = scope==='all' || scope==='plow' || scope==='stone';
  const planSeed = scope==='all' || scope==='seed';
  const planSpray = scope==='all' || scope==='spray';
  const planHarvest = scope==='all' || scope==='harvest';
  const seasonInfo = seasonFromMinutes(gameMinutes);
  const planSnow = seasonInfo.seasonIndex===3 && (scope==='all' || scope==='plow' || scope==='snow');

  const tractors = units.filter(u=>u.type===UnitType.TRACTOR);
  const sprayers = units.filter(u=>u.type===UnitType.SPRAYER);
  const harvesters = units.filter(u=>u.type===UnitType.HARVESTER);
  const caps = capacityNumbers();

  if(planPlow || planSeed || planSnow || planStone){
    tractors.forEach(t=>{ if(t.commands.length){ t.commands.length=0; markUnitListDirty(); } clearRestTarget(t); });
    if(planSnow){
      const snowRoads = listTilesWhere((x,y)=> tiles[y][x]===TileType.ROAD && getSnow(x,y)).map(p=>({...p, priority:0}));
      const snowFields = listTilesWhere((x,y)=> tiles[y][x]===TileType.FIELD && getSnow(x,y)).map(p=>({...p, priority:1}));
      const snowGrass = listTilesWhere((x,y)=> tiles[y][x]===TileType.GRASS && getSnow(x,y)).map(p=>({...p, priority:2}));
      const snowTargets = [...snowRoads, ...snowFields, ...snowGrass];
      assignUniqueTasks(tractors, snowTargets, caps.perDayPlow, ACTION.SNOW);
    }
    if(planStone){
      const stoneTargets = listTilesWhere((x,y)=> tiles[y][x]===TileType.FIELD && crops[y][x]===CROP_STAGE.BARE && !getStone(x,y));
      assignUniqueTasks(tractors, stoneTargets, caps.perDayPlow, ACTION.STONE);
    }
    if(planPlow){
      const bare = listTilesWhere((x,y)=> tiles[y][x]===TileType.FIELD && crops[y][x]===CROP_STAGE.BARE);
      assignUniqueTasks(tractors, bare, caps.perDayPlow, ACTION.PLOW);
    }
    if(planSeed){
      const plowed = listTilesWhere((x,y)=> tiles[y][x]===TileType.FIELD && crops[y][x]===CROP_STAGE.PLOWED);
      assignUniqueTasks(tractors, plowed, caps.perDaySeed, ACTION.SEED);
    }
  }

  if(planSpray){
    sprayers.forEach(s=>{ if(s.commands.length){ s.commands.length=0; markUnitListDirty(); } clearRestTarget(s); });
    const growWindow = listTilesWhere((x,y)=> tiles[y][x]===TileType.FIELD && crops[y][x]===CROP_STAGE.GROWING && ((()=>{const gp=growthProgress(x,y); return gp>=SPRAY_BEST_FROM && gp<=SPRAY_BEST_TO;})()));
    assignUniqueTasks(sprayers, growWindow, caps.perDaySpray, ACTION.SPRAY);
  }

  if(planHarvest){
    harvesters.forEach(h=>{ if(h.commands.length){ h.commands.length=0; markUnitListDirty(); } clearRestTarget(h); });
    const ready = listTilesWhere((x,y)=> tiles[y][x]===TileType.FIELD && crops[y][x]===CROP_STAGE.READY);
    assignUniqueTasks(harvesters, ready, caps.perDayHarvest, ACTION.HARVEST);
  }

  renderUnitList();
  saveGame();
}
planBtn.addEventListener('click', planCycle);
if(planScopeSel) planScopeSel.addEventListener('change', ()=>{ saveGame(); });
presetSel.addEventListener('change', ()=>{ applyPreset(); saveGame(); });

/* ===== Main Loop ===== */
let last = performance.now();
function loop(now){ const dt = paused ? 0 : (now-last)/1000; last = now; if(!paused){ updateGameClock(dt); updateCrops(dt); updateUnits(dt); } draw(); if(Math.floor(now/3000)!==Math.floor((now-dt*1000)/3000)) saveGame(); requestAnimationFrame(loop); }

function fastForwardMinutes(minutes){
  if(minutes<=0) return;
  const prevPaused = paused;
  const prevScale = timeScale;
  paused = true;
  timeScale = 1;
  const minutesPerRealSecond = MINUTES_PER_DAY / REAL_SECONDS_PER_INGAME_DAY;
  let remaining = minutes;
  const step = 0.5;
  while(remaining > 1e-6){
    const chunk = Math.min(step, remaining);
    const dt = chunk / minutesPerRealSecond;
    updateGameClock(dt, {skipHud:true});
    updateCrops(dt);
    updateUnits(dt);
    remaining -= chunk;
  }
  timeScale = prevScale;
  paused = prevPaused;
  last = performance.now();
  refreshHud();
  draw();
}

/* ===== Init ===== */
function startNewGame(){ money = 7000; gameMinutes = 8*60; paused=false; timeScale=1; viewScale = 1; viewOffsetX = 0; viewOffsetY = 0; clampView(); initMap(true); initUnits(); lastSeasonIndex = seasonFromMinutes(gameMinutes).seasonIndex; selectedTile = getHubSpawn(); applyPreset(); renderTileInfo(); refreshHud(); renderUnitList(); saveGame(); }
function start(){ const loaded = loadGame(); if(!loaded){ startNewGame(); } else { ensureGridDims(); applyPreset(); ensureOwnerTractor(); clampView(); refreshHud(); lastSeasonIndex = seasonFromMinutes(gameMinutes).seasonIndex; renderUnitList(); } last = performance.now(); requestAnimationFrame(loop); runTests(); }

runTestsBtn.addEventListener('click', runTests);
window.addEventListener('resize', ()=>{ requestAnimationFrame(resizeCanvasViewport); });
if(howToDetails){
  howToDetails.addEventListener('toggle', ()=>{ requestAnimationFrame(resizeCanvasViewport); });
}
requestAnimationFrame(resizeCanvasViewport);
start();
</script>
</body>
</html>
